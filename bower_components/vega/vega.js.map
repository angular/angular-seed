{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "node_modules/browserify/node_modules/browser-resolve/empty.js",
    "node_modules/datalib/node_modules/d3-dsv/build/d3-dsv.js",
    "node_modules/datalib/node_modules/d3-format/build/d3-format.js",
    "node_modules/datalib/node_modules/d3-time-format/build/d3-time-format.js",
    "node_modules/datalib/node_modules/d3-time-format/node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/src/accessor.js",
    "node_modules/datalib/src/aggregate/aggregator.js",
    "node_modules/datalib/src/aggregate/collector.js",
    "node_modules/datalib/src/aggregate/groupby.js",
    "node_modules/datalib/src/aggregate/measures.js",
    "node_modules/datalib/src/bins/bins.js",
    "node_modules/datalib/src/bins/histogram.js",
    "node_modules/datalib/src/format-tables.js",
    "node_modules/datalib/src/format.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/formats/dsv.js",
    "node_modules/datalib/src/import/formats/index.js",
    "node_modules/datalib/src/import/formats/json.js",
    "node_modules/datalib/src/import/formats/topojson.js",
    "node_modules/datalib/src/import/formats/treejson.js",
    "node_modules/datalib/src/import/load.js",
    "node_modules/datalib/src/import/read.js",
    "node_modules/datalib/src/import/readers.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/index.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/template.js",
    "node_modules/datalib/src/time.js",
    "node_modules/datalib/src/util.js",
    "node_modules/topojson/topojson.js",
    "node_modules/vega-dataflow/src/ChangeSet.js",
    "node_modules/vega-dataflow/src/Collector.js",
    "node_modules/vega-dataflow/src/DataSource.js",
    "node_modules/vega-dataflow/src/Dependencies.js",
    "node_modules/vega-dataflow/src/Graph.js",
    "node_modules/vega-dataflow/src/Heap.js",
    "node_modules/vega-dataflow/src/Node.js",
    "node_modules/vega-dataflow/src/Signal.js",
    "node_modules/vega-dataflow/src/Tuple.js",
    "node_modules/vega-dataflow/src/index.js",
    "node_modules/vega-expression/src/codegen.js",
    "node_modules/vega-expression/src/constants.js",
    "node_modules/vega-expression/src/functions.js",
    "node_modules/vega-expression/src/index.js",
    "node_modules/vega-expression/src/parser.js",
    "node_modules/vega-logging/index.js",
    "node_modules/vega-scenegraph/src/index.js",
    "node_modules/vega-scenegraph/src/path/arc.js",
    "node_modules/vega-scenegraph/src/path/index.js",
    "node_modules/vega-scenegraph/src/path/parse.js",
    "node_modules/vega-scenegraph/src/path/render.js",
    "node_modules/vega-scenegraph/src/render/Handler.js",
    "node_modules/vega-scenegraph/src/render/Renderer.js",
    "node_modules/vega-scenegraph/src/render/canvas/CanvasHandler.js",
    "node_modules/vega-scenegraph/src/render/canvas/CanvasRenderer.js",
    "node_modules/vega-scenegraph/src/render/canvas/index.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/arc.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/area.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/group.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/image.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/index.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/line.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/path.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/rect.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/rule.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/symbol.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/text.js",
    "node_modules/vega-scenegraph/src/render/canvas/marks/util.js",
    "node_modules/vega-scenegraph/src/render/index.js",
    "node_modules/vega-scenegraph/src/render/svg/SVGHandler.js",
    "node_modules/vega-scenegraph/src/render/svg/SVGRenderer.js",
    "node_modules/vega-scenegraph/src/render/svg/SVGStringRenderer.js",
    "node_modules/vega-scenegraph/src/render/svg/index.js",
    "node_modules/vega-scenegraph/src/render/svg/marks.js",
    "node_modules/vega-scenegraph/src/util/Bounds.js",
    "node_modules/vega-scenegraph/src/util/BoundsContext.js",
    "node_modules/vega-scenegraph/src/util/Gradient.js",
    "node_modules/vega-scenegraph/src/util/ImageLoader.js",
    "node_modules/vega-scenegraph/src/util/Item.js",
    "node_modules/vega-scenegraph/src/util/bound.js",
    "node_modules/vega-scenegraph/src/util/canvas.js",
    "node_modules/vega-scenegraph/src/util/dom.js",
    "node_modules/vega-scenegraph/src/util/scene.js",
    "node_modules/vega-scenegraph/src/util/svg.js",
    "node_modules/vega-scenegraph/src/util/text.js",
    "src/core/HeadlessView.js",
    "src/core/Model.js",
    "src/core/View.js",
    "src/core/config.js",
    "src/core/schema.js",
    "src/parse/axes.js",
    "src/parse/background.js",
    "src/parse/data.js",
    "src/parse/events.js",
    "src/parse/expr.js",
    "src/parse/index.js",
    "src/parse/legends.js",
    "src/parse/mark.js",
    "src/parse/marks.js",
    "src/parse/modify.js",
    "src/parse/padding.js",
    "src/parse/predicates.js",
    "src/parse/properties.js",
    "src/parse/signals.js",
    "src/parse/spec.js",
    "src/parse/streams.js",
    "src/parse/transforms.js",
    "src/scene/Bounder.js",
    "src/scene/Builder.js",
    "src/scene/Encoder.js",
    "src/scene/GroupBuilder.js",
    "src/scene/Scale.js",
    "src/scene/Transition.js",
    "src/scene/axis.js",
    "src/scene/legend.js",
    "src/scene/visit.js",
    "src/transforms/Aggregate.js",
    "src/transforms/BatchTransform.js",
    "src/transforms/Bin.js",
    "src/transforms/CountPattern.js",
    "src/transforms/Cross.js",
    "src/transforms/Facet.js",
    "src/transforms/Facetor.js",
    "src/transforms/Filter.js",
    "src/transforms/Fold.js",
    "src/transforms/Force.js",
    "src/transforms/Formula.js",
    "src/transforms/Geo.js",
    "src/transforms/GeoPath.js",
    "src/transforms/Hierarchy.js",
    "src/transforms/Impute.js",
    "src/transforms/LinkPath.js",
    "src/transforms/Lookup.js",
    "src/transforms/Parameter.js",
    "src/transforms/Pie.js",
    "src/transforms/Sort.js",
    "src/transforms/Stack.js",
    "src/transforms/Transform.js",
    "src/transforms/Treeify.js",
    "src/transforms/Treemap.js",
    "src/transforms/Voronoi.js",
    "src/transforms/Wordcloud.js",
    "src/transforms/index.js",
    "src/transforms/screen.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACthBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChQA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxIA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACplCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACphBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "module.exports = {\n  version: '2.4.2',\n  dataflow: require('vega-dataflow'),\n  parse: require('./src/parse/'),\n  scene: {\n    Bounder: require('./src/scene/Bounder'),\n    Builder: require('./src/scene/Builder'),\n    Encoder: require('./src/scene/Encoder'),\n    GroupBuilder: require('./src/scene/GroupBuilder'),\n  },\n  transforms: require('./src/transforms'),\n  Transform: require('./src/transforms/Transform'),\n  BatchTransform: require('./src/transforms/BatchTransform'),\n  Parameter: require('./src/transforms/Parameter'),\n  schema: require('./src/core/schema'),\n  config: require('./src/core/config'),\n  util:  require('datalib'),\n  logging: require('vega-logging'),\n  debug: require('vega-logging').debug\n};",
    null,
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-dsv', ['exports'], factory) :\n  factory((global.d3_dsv = {}));\n}(this, function (exports) { 'use strict';\n\n  function dsv(delimiter) {\n    return new Dsv(delimiter);\n  }\n\n  function objectConverter(columns) {\n    return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n      return JSON.stringify(name) + \": d[\" + i + \"]\";\n    }).join(\",\") + \"}\");\n  }\n\n  function customConverter(columns, f) {\n    var object = objectConverter(columns);\n    return function(row, i) {\n      return f(object(row), i, columns);\n    };\n  }\n\n  // Compute unique columns in order of discovery.\n  function inferColumns(rows) {\n    var columnSet = Object.create(null),\n        columns = [];\n\n    rows.forEach(function(row) {\n      for (var column in row) {\n        if (!(column in columnSet)) {\n          columns.push(columnSet[column] = column);\n        }\n      }\n    });\n\n    return columns;\n  }\n\n  function Dsv(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    this.parse = function(text, f) {\n      var convert, columns, rows = this.parseRows(text, function(row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n      rows.columns = columns;\n      return rows;\n    };\n\n    this.parseRows = function(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    this.format = function(rows, columns) {\n      if (arguments.length < 2) columns = inferColumns(rows);\n      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return columns.map(function(column) {\n          return formatValue(row[column]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n\n    this.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return reFormat.test(text) ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n    }\n  };\n\n  dsv.prototype = Dsv.prototype;\n\n  var csv = dsv(\",\");\n  var tsv = dsv(\"\\t\");\n\n  var version = \"0.1.12\";\n\n  exports.version = version;\n  exports.dsv = dsv;\n  exports.csv = csv;\n  exports.tsv = tsv;\n\n}));",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-format', ['exports'], factory) :\n  factory((global.d3_format = {}));\n}(this, function (exports) { 'use strict';\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  };\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  };\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n  };\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  };\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  };\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  };\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // If the original value was negative, it may be rounded to zero during\n          // formatting; treat this as (positive) zero.\n          if (valueNegative) {\n            var i = -1, n = value.length, c;\n            valueNegative = false;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), (48 < c && c < 58)\n                  || (type === \"x\" && 96 < c && c < 103)\n                  || (type === \"X\" && 64 < c && c < 71)) {\n                valueNegative = true;\n                break;\n              }\n            }\n          }\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  };\n\n  var defaultLocale = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  var caES = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var deCH = locale({\n    decimal: \",\",\n    thousands: \"'\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0CHF\"]\n  });\n\n  var deDE = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var enCA = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  var enGB = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var esES = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var fiFI = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var frCA = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  });\n\n  var frFR = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var heIL = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var huHU = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0Ft\"]\n  });\n\n  var itIT = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var jaJP = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var koKR = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var mkMK = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  });\n\n  var nlNL = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  });\n\n  var plPL = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  });\n\n  var ptBR = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  });\n\n  var ruRU = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  });\n\n  var svSE = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"SEK\"]\n  });\n\n  var zhCN = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  };\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  };\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  };\n\n  var format = defaultLocale.format;\n  var formatPrefix = defaultLocale.formatPrefix;\n\n  var version = \"0.4.0\";\n\n  exports.version = version;\n  exports.format = format;\n  exports.formatPrefix = formatPrefix;\n  exports.locale = locale;\n  exports.localeCaEs = caES;\n  exports.localeDeCh = deCH;\n  exports.localeDeDe = deDE;\n  exports.localeEnCa = enCA;\n  exports.localeEnGb = enGB;\n  exports.localeEnUs = defaultLocale;\n  exports.localeEsEs = esES;\n  exports.localeFiFi = fiFI;\n  exports.localeFrCa = frCA;\n  exports.localeFrFr = frFR;\n  exports.localeHeIl = heIL;\n  exports.localeHuHu = huHU;\n  exports.localeItIt = itIT;\n  exports.localeJaJp = jaJP;\n  exports.localeKoKr = koKR;\n  exports.localeMkMk = mkMK;\n  exports.localeNlNl = nlNL;\n  exports.localePlPl = plPL;\n  exports.localePtBr = ptBR;\n  exports.localeRuRu = ruRU;\n  exports.localeSvSe = svSE;\n  exports.localeZhCn = zhCN;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :\n  typeof define === 'function' && define.amd ? define('d3-time-format', ['exports', 'd3-time'], factory) :\n  factory((global.d3_time_format = {}),global.d3_time);\n}(this, function (exports,d3Time) { 'use strict';\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale$1(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodRe = formatRe(locale_periods),\n        periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        if (!(date instanceof Date)) date = new Date(+date);\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            else pad = c === \"e\" ? \" \" : \"0\";\n            if (format = formats[c]) c = format(date, pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string += \"\", 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // Convert day-of-week and week-of-year to day-of-year.\n        if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          var day = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n          d.m = 0;\n          d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n        }\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodRe.exec(string.slice(i));\n      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  };\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = {}, i = -1, n = names.length;\n    while (++i < n) map[names[i].toLowerCase()] = i;\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + d3Time.day.count(d3Time.year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(d3Time.sunday.count(d3Time.year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(d3Time.monday.count(d3Time.year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var locale = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var caES = locale$1({\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  });\n\n  var deCH = locale$1({\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  });\n\n  var deDE = locale$1({\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  });\n\n  var enCA = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var enGB = locale$1({\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var esES = locale$1({\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  });\n\n  var fiFI = locale$1({\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  });\n\n  var frCA = locale$1({\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  });\n\n  var frFR = locale$1({\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  });\n\n  var heIL = locale$1({\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var huHU = locale$1({\n    dateTime: \"%Y. %B %-e., %A %X\",\n    date: \"%Y. %m. %d.\",\n    time: \"%H:%M:%S\",\n    periods: [\"de.\", \"du.\"], // unused\n    days: [\"vasrnap\", \"htf\", \"kedd\", \"szerda\", \"cstrtk\", \"pntek\", \"szombat\"],\n    shortDays: [\"V\", \"H\", \"K\", \"Sze\", \"Cs\", \"P\", \"Szo\"],\n    months: [\"janur\", \"februr\", \"mrcius\", \"prilis\", \"mjus\", \"jnius\", \"jlius\", \"augusztus\", \"szeptember\", \"oktber\", \"november\", \"december\"],\n    shortMonths: [\"jan.\", \"feb.\", \"mr.\", \"pr.\", \"mj.\", \"jn.\", \"jl.\", \"aug.\", \"szept.\", \"okt.\", \"nov.\", \"dec.\"]\n  });\n\n  var itIT = locale$1({\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  });\n\n  var jaJP = locale$1({\n    dateTime: \"%Y %b %e %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]\n  });\n\n  var koKR = locale$1({\n    dateTime: \"%Y/%m/%d %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"],\n    shortMonths: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]\n  });\n\n  var mkMK = locale$1({\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var nlNL = locale$1({\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  });\n\n  var plPL = locale$1({\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  });\n\n  var ptBR = locale$1({\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  });\n\n  var ruRU = locale$1({\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var svSE = locale$1({\n    dateTime: \"%A den %d %B %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"fm\", \"em\"],\n    days: [\"Sndag\", \"Mndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"],\n    shortDays: [\"Sn\", \"Mn\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"],\n    months: [\"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"]\n  });\n\n  var zhCN = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var format = locale.format;\n  var utcFormat = locale.utcFormat;\n\n  var version = \"0.2.0\";\n\n  exports.version = version;\n  exports.format = format;\n  exports.utcFormat = utcFormat;\n  exports.locale = locale$1;\n  exports.localeCaEs = caES;\n  exports.localeDeCh = deCH;\n  exports.localeDeDe = deDE;\n  exports.localeEnCa = enCA;\n  exports.localeEnGb = enGB;\n  exports.localeEnUs = locale;\n  exports.localeEsEs = esES;\n  exports.localeFiFi = fiFI;\n  exports.localeFrCa = frCA;\n  exports.localeFrFr = frFR;\n  exports.localeHeIl = heIL;\n  exports.localeHuHu = huHU;\n  exports.localeItIt = itIT;\n  exports.localeJaJp = jaJP;\n  exports.localeKoKr = koKR;\n  exports.localeMkMk = mkMK;\n  exports.localeNlNl = nlNL;\n  exports.localePlPl = plPL;\n  exports.localePtBr = ptBR;\n  exports.localeRuRu = ruRU;\n  exports.localeSvSe = svSE;\n  exports.localeZhCn = zhCN;\n  exports.isoFormat = formatIso;\n\n}));",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.0.7\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.0\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('./util'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports;\n\nu.$year   = util.$func('year', time.year.unit);\nu.$month  = util.$func('month', time.months.unit);\nu.$date   = util.$func('date', time.dates.unit);\nu.$day    = util.$func('day', time.weekdays.unit);\nu.$hour   = util.$func('hour', time.hours.unit);\nu.$minute = util.$func('minute', time.minutes.unit);\nu.$second = util.$func('second', time.seconds.unit);\n\nu.$utcYear   = util.$func('utcYear', utc.year.unit);\nu.$utcMonth  = util.$func('utcMonth', utc.months.unit);\nu.$utcDate   = util.$func('utcDate', utc.dates.unit);\nu.$utcDay    = util.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = util.$func('utcHour', utc.hours.unit);\nu.$utcMinute = util.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = util.$func('utcSecond', utc.seconds.unit);\n",
    "var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x, key));\n};\n\nproto._newcell = function(x, key) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, key),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_add) this._on_add(x, cell);\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_rem) this._on_rem(x, cell);\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);\n};\n\nproto._markMod = function(x) {\n  var cell0 = this._cell(x);\n  cell0.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      // consolidate collector values\n      if (cell.collect) {\n        cell.data.values();\n      }\n      // update tuple properties\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      // add output tuple\n      result.push(cell.tuple);\n    } else {\n      delete this._cells[k];\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function(output) {\n  var changes = output || {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??\n      delete this._cells[k];\n      if (this._on_drop) this._on_drop(cell);\n    } else {\n      if (this._on_keep) this._on_keep(cell);\n      if (flag & Flags.ADD_CELL) {\n        changes.add.push(cell.tuple);\n      } else if (flag & Flags.MOD_CELL) {\n        changes.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n",
    "var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m != null ? get(m) : +Infinity;\n};\n\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m != null ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;\n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n",
    "var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n",
    "var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.valid > 1 ? this.dev / this.valid : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  ctr.fields = agg.map(util.$('out'));\n  return ctr;\n}\n\ntypes.create = create;\nmodule.exports = types;\n",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var bins = require('./bins'),\n    gen  = require('../generate'),\n    type = require('../import/type'),\n    util = require('../util'),\n    stats = require('../stats');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n\n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n",
    "var util = require('./util'),\n    type = require('./import/type'),\n    stats = require('./stats'),\n    template = require('./template');\n\nmodule.exports = {\n  table:   formatTable,  // format a data table\n  summary: formatSummary // format a data table summary\n};\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nfunction formatTable(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n}\n\nfunction formatSummary(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}",
    "var util = require('./util'),\n    d3_time = require('d3-time'),\n    d3_timeF = require('d3-time-format'),\n    d3_numberF = require('d3-format'),\n    numberF = d3_numberF, // defaults to EN-US\n    timeF = d3_timeF,     // defaults to EN-US\n    tmpDate = new Date(2000, 0, 1),\n    monthFull, monthAbbr, dayFull, dayAbbr;\n\n\nmodule.exports = {\n  // Update number formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-format\n  numberLocale: numberLocale,\n  number:       function(f) { return numberF.format(f); },\n  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },\n\n  // Update time formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-time-format\n  timeLocale:   timeLocale,\n  time:         function(f) { return timeF.format(f); },\n  utc:          function(f) { return timeF.utcFormat(f); },\n\n  // Set number and time locale simultaneously.\n  locale:       function(l) { numberLocale(l); timeLocale(l); },\n\n  // automatic formatting functions\n  auto: {\n    number:   autoNumberFormat,\n    linear:   linearNumberFormat,\n    time:     function() { return timeAutoFormat(); },\n    utc:      function() { return utcAutoFormat(); }\n  },\n\n  month: monthFormat, // format month name from integer code\n  day:   dayFormat    // format week day name from integer code\n};\n\n// -- Locales ----\n\n// transform 'en-US' style locale string to match d3-format v0.4+ convention\nfunction localeRef(l) {\n  return l.length > 4 && 'locale' + (\n    l[0].toUpperCase() + l[1].toLowerCase() +\n    l[3].toUpperCase() + l[4].toLowerCase()\n  );\n}\n\nfunction numberLocale(l) {\n  var f = util.isString(l) ? d3_numberF[localeRef(l)] : d3_numberF.locale(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  numberF = f;\n}\n\nfunction timeLocale(l) {\n  var f = util.isString(l) ? d3_timeF[localeRef(l)] : d3_timeF.locale(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  timeF = f;\n  monthFull = monthAbbr = dayFull = dayAbbr = null;\n}\n\n// -- Number Formatting ----\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction linearRange(domain, count) {\n  if (!domain.length) domain = [0];\n  if (count == null) count = 10;\n\n  var start = domain[0],\n      stop = domain[domain.length - 1];\n\n  if (stop < start) { error = stop; stop = start; start = error; }\n\n  var span = (stop - start) || (count = 1, start || stop || 1),\n      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),\n      error = span / count / step;\n\n  // Filter ticks to get closer to the desired count.\n  if (error >= e10) step *= 10;\n  else if (error >= e5) step *= 5;\n  else if (error >= e2) step *= 2;\n\n  // Round start and stop values to step interval.\n  return [\n    Math.ceil(start / step) * step,\n    Math.floor(stop / step) * step + step / 2, // inclusive\n    step\n  ];\n}\n\nfunction trimZero(f, decimal) {\n  return function(x) {\n    var s = f(x),\n        n = s.indexOf(decimal);\n    if (n < 0) return s;\n\n    var idx = rightmostDigit(s, n),\n        end = idx < s.length ? s.slice(idx) : '';\n\n    while (--idx > n) {\n      if (s[idx] !== '0') { ++idx; break; }\n    }\n    return s.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(s, n) {\n  var i = s.lastIndexOf('e'), c;\n  if (i > 0) return i;\n  for (i=s.length; --i > n;) {\n    c = s.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i+1; // is digit\n  }\n}\n\nfunction autoNumberFormat(f) {\n  var decimal = numberF.format('.1f')(1)[1]; // get decimal char\n  if (f == null) f = ',';\n  f = d3_numberF.formatSpecifier(f);\n  if (f.precision == null) f.precision = 12;\n  switch (f.type) {\n    case '%': f.precision -= 2; break;\n    case 'e': f.precision -= 1; break;\n  }\n  return trimZero(numberF.format(f), decimal);\n}\n\nfunction linearNumberFormat(domain, count, f) {\n  var range = linearRange(domain, count);\n\n  if (f == null) f = ',f';\n\n  switch (f = d3_numberF.formatSpecifier(f), f.type) {\n    case 's': {\n      var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));\n      if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);\n      return numberF.formatPrefix(f, value);\n    }\n    case '':\n    case 'e':\n    case 'g':\n    case 'p':\n    case 'r': {\n      if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');\n      break;\n    }\n    case 'f':\n    case '%': {\n      if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - 2 * (f.type === '%');\n      break;\n    }\n  }\n  return numberF.format(f);\n}\n\n// -- Datetime Formatting ----\n\nfunction timeAutoFormat() {\n  var f = timeF.format,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.second(date) < d ? formatMillisecond\n        : d3_time.minute(date) < d ? formatSecond\n        : d3_time.hour(date) < d ? formatMinute\n        : d3_time.day(date) < d ? formatHour\n        : d3_time.month(date) < d ?\n          (d3_time.week(date) < d ? formatDay : formatWeek)\n        : d3_time.year(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction utcAutoFormat() {\n  var f = timeF.utcFormat,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.utcSecond(date) < d ? formatMillisecond\n        : d3_time.utcMinute(date) < d ? formatSecond\n        : d3_time.utcHour(date) < d ? formatMinute\n        : d3_time.utcDay(date) < d ? formatHour\n        : d3_time.utcMonth(date) < d ?\n          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)\n        : d3_time.utcYear(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction monthFormat(month, abbreviate) {\n  var f = abbreviate ?\n    (monthAbbr || (monthAbbr = timeF.format('%b'))) :\n    (monthFull || (monthFull = timeF.format('%B')));\n  return (tmpDate.setMonth(month), f(tmpDate));\n}\n\nfunction dayFormat(day, abbreviate) {\n  var f = abbreviate ?\n    (dayAbbr || (dayAbbr = timeF.format('%a'))) :\n    (dayFull || (dayFull = timeF.format('%A')));\n  return (tmpDate.setMonth(0), tmpDate.setDate(2 + day), f(tmpDate));\n}",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var util = require('../../util');\nvar d3_dsv = require('d3-dsv');\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3_dsv.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n",
    "var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n",
    "var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n",
    "var json = require('./json');\n\nvar reader = function(data, format) {\n  var topojson = reader.topojson;\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n};\n\nreader.topojson = require('topojson');\nmodule.exports = reader;\n",
    "var json = require('./json');\n\nmodule.exports = function(tree, format) {\n  return toTable(json(tree, format), format);\n};\n\nfunction toTable(root, fields) {\n  var childrenField = fields && fields.children || 'children',\n      parentField = fields && fields.parent || 'parent',\n      table = [];\n\n  function visit(node, parent) {\n    node[parentField] = parent;\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n\n  visit(root, null);\n  return (table.root = root, table);\n}\n",
    "var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (!load.useXHR && startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (load.useXHR) {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    } else {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  return load.loader(opt, callback);\n}\n\nfunction loader(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + opt.url);\n  } else if (load.useXHR) {\n    // on client, use xhr\n    return load.xhr(url, opt, callback);\n  } else if (startsWith(url, fileProtocol)) {\n    // on server, if url starts with 'file://', strip it and load from file\n    return load.file(url.slice(fileProtocol.length), opt, callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // on server, if no protocol assume file\n    return load.file(url, opt, callback);\n  } else {\n    // for regular URLs on server\n    return load.http(url, opt, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, opt, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (typeof XDomainRequest !== 'undefined' &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n\n  request.open('GET', url, async);\n  /* istanbul ignore else */\n  if (request.setRequestHeader) {\n    var headers = util.extend({}, load.headers, opt.headers);\n    for (var name in headers) {\n      request.setRequestHeader(name, headers[name]);\n    }\n  }\n  request.send();\n\n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, opt, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  fs.readFile(filename, callback);\n}\n\nfunction http(url, opt, callback) {\n  var headers = util.extend({}, load.headers, opt.headers);\n\n  if (!callback) {\n    return require('sync-request')('GET', url, {headers: headers}).getBody();\n  }\n\n  var options = {url: url, encoding: null, gzip: true, headers: headers};\n  require('request')(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      error = error ||\n        'Load failed with response code ' + response.statusCode + '.';\n      callback(error, null);\n    }\n  });\n}\n\nfunction startsWith(string, searchString) {\n  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;\n}\n\n// Allow these functions to be overriden by the user of the library\nload.loader = loader;\nload.sanitizeUrl = sanitizeUrl;\nload.xhr = xhr;\nload.file = file;\nload.http = http;\n\n// Default settings\nload.useXHR = (typeof XMLHttpRequest !== 'undefined');\nload.headers = {};\n\nmodule.exports = load;\n",
    "var util = require('../util'),\n  type = require('./type'),\n  formats = require('./formats'),\n  timeF = require('../format').time;\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) {\n    var t = types[c];\n    if (t && t.indexOf('date:') === 0) {\n      var parts = t.split(':', 2),\n          pattern = parts[1];\n      if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n          (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n        pattern = pattern.slice(1, -1);\n      } else {\n        throw Error('Format pattern must be quoted: ' + pattern);\n      }\n      pattern = timeF(pattern);\n      return function(v) { return pattern.parse(v); };\n    }\n    if (!type.parsers[t]) {\n      throw Error('Illegal format pattern: ' + c + ':' + t);\n    }\n    return type.parsers[t];\n  });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n",
    "var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) { callback(error, null); return; }\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      } : undefined);\n\n      // data loaded, now parse it (sync)\n      if (!callback) return read(data, format);\n    };\n    return out;\n  }, {});\n",
    "var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n",
    "var util = require('./util');\n\nvar dl = {\n  version:    '1.5.8',\n  load:       require('./import/load'),\n  read:       require('./import/read'),\n  type:       require('./import/type'),\n  Aggregator: require('./aggregate/aggregator'),\n  groupby:    require('./aggregate/groupby'),\n  bins:       require('./bins/bins'),\n  $bin:       require('./bins/histogram').$bin,\n  histogram:  require('./bins/histogram').histogram,\n  format:     require('./format'),\n  template:   require('./template'),\n  time:       require('./time')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./accessor'));\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\nutil.extend(dl.format, require('./format-tables'));\n\n// backwards-compatible, deprecated API\n// will remove in the future\ndl.print = {\n  table:   dl.format.table,\n  summary: dl.format.summary\n};\n\nmodule.exports = dl;\n",
    "var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n",
    "var util = require('./util'),\n    format = require('./format');\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad,\n  day:        format.day,\n  month:      format.month\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  /* jshint evil: true */\n  return (new Function('d', src)).bind(context);\n}\n\ntemplate.source = source;\ntemplate.context = context;\ntemplate.format = get_format;\nmodule.exports = template;\n\n// Clear cache of format objects.\n// This can *break* prior template functions, so invoke with care!\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\n// Generate property access code for use within template source.\n// object: the name of the object (variable) containing template data\n// property: the property access string, verbatim from template tag\ntemplate.property = function(object, property) {\n  var src = util.field(property).map(util.str).join('][');\n  return object + '[' + src + ']';\n};\n\n// Generate source code for a template function.\n// text: the template text\n// variable: the name of the data object variable ('obj' by default)\n// properties: optional hash for collecting all accessed properties\nfunction source(text, variable, properties) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable, properties) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable, properties) {\n  var filters = text.match(filter_re);\n  var prop = filters.shift().trim();\n  var stringCast = true;\n\n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n\n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n\n  function formatter(type) {\n    var pattern = args[0];\n    if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n        (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n      pattern = pattern.slice(1, -1);\n    } else {\n      throw Error('Format pattern must be quoted: ' + pattern);\n    }\n    a = template_format(pattern, type);\n    stringCast = false;\n    var arg = type === 'number' ? src : date();\n    src = 'this.formats['+a+']('+arg+')';\n  }\n\n  if (properties) properties[prop] = 1;\n  var src = template.property(variable, prop);\n\n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1)\n        .match(args_re)\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        formatter('number');\n        break;\n      case 'time':\n        formatter('time');\n        break;\n      case 'time-utc':\n        formatter('utc');\n        break;\n      case 'month':\n        src = 'this.month(' + src + ')';\n        break;\n      case 'month-abbrev':\n        src = 'this.month(' + src + ',true)';\n        break;\n      case 'day':\n        src = 'this.day(' + src + ')';\n        break;\n      case 'day-abbrev':\n        src = 'this.day(' + src + ',true)';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g,\n    filter_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^\\|\"]+|[^\\|\\']+)+/g,\n    args_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^,\"]+|[^,\\']+)+/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, type) {\n  var key = type + ':' + pattern;\n  if (context.format_map[key] == null) {\n    var f = format[type](pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[key] = i;\n    return i;\n  }\n  return context.format_map[key];\n}\n\nfunction get_format(pattern, type) {\n  return context.formats[template_format(pattern, type)];\n}\n",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "!function() {\n  var topojson = {\n    version: \"1.6.19\",\n    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },\n    meshArcs: meshArcs,\n    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },\n    mergeArcs: mergeArcs,\n    feature: featureOrCollection,\n    neighbors: neighbors,\n    presimplify: presimplify\n  };\n\n  function stitchArcs(topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function(i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i], t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n\n    arcs.forEach(function(i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f, g;\n\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n      else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n        fragments.push(f);\n      }\n    }\n\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n    return fragments;\n  }\n\n  function meshArcs(topology, o, filter) {\n    var arcs = [];\n\n    if (arguments.length > 1) {\n      var geomsByArc = [],\n          geom;\n\n      function arc(i) {\n        var j = i < 0 ? ~i : i;\n        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n      }\n\n      function line(arcs) {\n        arcs.forEach(arc);\n      }\n\n      function polygon(arcs) {\n        arcs.forEach(line);\n      }\n\n      function geometry(o) {\n        if (o.type === \"GeometryCollection\") o.geometries.forEach(geometry);\n        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);\n      }\n\n      var geometryType = {\n        LineString: line,\n        MultiLineString: polygon,\n        Polygon: polygon,\n        MultiPolygon: function(arcs) { arcs.forEach(polygon); }\n      };\n\n      geometry(o);\n\n      geomsByArc.forEach(arguments.length < 3\n          ? function(geoms) { arcs.push(geoms[0].i); }\n          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n    } else {\n      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);\n    }\n\n    return {type: \"MultiLineString\", arcs: stitchArcs(topology, arcs)};\n  }\n\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        components = [];\n\n    objects.forEach(function(o) {\n      if (o.type === \"Polygon\") register(o.arcs);\n      else if (o.type === \"MultiPolygon\") o.arcs.forEach(register);\n    });\n\n    function register(polygon) {\n      polygon.forEach(function(ring) {\n        ring.forEach(function(arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n\n    function exterior(ring) {\n      return cartesianRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?\n    }\n\n    polygons.forEach(function(polygon) {\n      if (!polygon._) {\n        var component = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        components.push(component);\n        while (polygon = neighbors.pop()) {\n          component.push(polygon);\n          polygon.forEach(function(ring) {\n            ring.forEach(function(arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n\n    polygons.forEach(function(polygon) {\n      delete polygon._;\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      arcs: components.map(function(polygons) {\n        var arcs = [];\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function(polygon) {\n          polygon.forEach(function(ring) {\n            ring.forEach(function(arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitchArcs(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // this exterior ring has the same winding order\n        // as any exterior ring in the original polygons.\n        if ((n = arcs.length) > 1) {\n          var sgn = exterior(polygons[0][0]);\n          for (var i = 0, t; i < n; ++i) {\n            if (sgn === exterior(arcs[i])) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;\n              break;\n            }\n          }\n        }\n\n        return arcs;\n      })\n    };\n  }\n\n  function featureOrCollection(topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function(o) { return feature(topology, o); })\n    } : feature(topology, o);\n  }\n\n  function feature(topology, o) {\n    var f = {\n      type: \"Feature\",\n      id: o.id,\n      properties: o.properties || {},\n      geometry: object(topology, o)\n    };\n    if (o.id == null) delete f.id;\n    return f;\n  }\n\n  function object(topology, o) {\n    var absolute = transformAbsolute(topology.transform),\n        arcs = topology.arcs;\n\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {\n        points.push(p = a[k].slice());\n        absolute(p, k);\n      }\n      if (i < 0) reverse(points, n);\n    }\n\n    function point(p) {\n      p = p.slice();\n      absolute(p, 0);\n      return p;\n    }\n\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0].slice());\n      return points;\n    }\n\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0].slice());\n      return points;\n    }\n\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n\n    function geometry(o) {\n      var t = o.type;\n      return t === \"GeometryCollection\" ? {type: t, geometries: o.geometries.map(geometry)}\n          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}\n          : null;\n    }\n\n    var geometryType = {\n      Point: function(o) { return point(o.coordinates); },\n      MultiPoint: function(o) { return o.coordinates.map(point); },\n      LineString: function(o) { return line(o.arcs); },\n      MultiLineString: function(o) { return o.arcs.map(line); },\n      Polygon: function(o) { return polygon(o.arcs); },\n      MultiPolygon: function(o) { return o.arcs.map(polygon); }\n    };\n\n    return geometry(o);\n  }\n\n  function reverse(array, n) {\n    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n\n  function bisect(a, x) {\n    var lo = 0, hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function neighbors(objects) {\n    var indexesByArc = {}, // arc index -> array of object indexes\n        neighbors = objects.map(function() { return []; });\n\n    function line(arcs, i) {\n      arcs.forEach(function(a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);\n        else indexesByArc[a] = [i];\n      });\n    }\n\n    function polygon(arcs, i) {\n      arcs.forEach(function(arc) { line(arc, i); });\n    }\n\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n    };\n\n    objects.forEach(geometry);\n\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j], ik = indexes[k], n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  function presimplify(topology, triangleArea) {\n    var absolute = transformAbsolute(topology.transform),\n        relative = transformRelative(topology.transform),\n        heap = minAreaHeap();\n\n    if (!triangleArea) triangleArea = cartesianTriangleArea;\n\n    topology.arcs.forEach(function(arc) {\n      var triangles = [],\n          maxArea = 0,\n          triangle;\n\n      // To store each points effective area, we create a new array rather than\n      // extending the passed-in point to workaround a Chrome/V8 bug (getting\n      // stuck in smi mode). For midpoints, the initial effective area of\n      // Infinity will be computed in the next step.\n      for (var i = 0, n = arc.length, p; i < n; ++i) {\n        p = arc[i];\n        absolute(arc[i] = [p[0], p[1], Infinity], i);\n      }\n\n      for (var i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = arc.slice(i - 1, i + 2);\n        triangle[1][2] = triangleArea(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      }\n\n      for (var i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n\n      while (triangle = heap.pop()) {\n        var previous = triangle.previous,\n            next = triangle.next;\n\n        // If the area of the current point is less than that of the previous point\n        // to be eliminated, use the latter's area instead. This ensures that the\n        // current point cannot be eliminated without eliminating previously-\n        // eliminated points.\n        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;\n        else maxArea = triangle[1][2];\n\n        if (previous) {\n          previous.next = next;\n          previous[2] = triangle[2];\n          update(previous);\n        }\n\n        if (next) {\n          next.previous = previous;\n          next[0] = triangle[0];\n          update(next);\n        }\n      }\n\n      arc.forEach(relative);\n    });\n\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = triangleArea(triangle);\n      heap.push(triangle);\n    }\n\n    return topology;\n  };\n\n  function cartesianRingArea(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) {\n      a = b;\n      b = ring[i];\n      area += a[0] * b[1] - a[1] * b[0];\n    }\n\n    return area * .5;\n  }\n\n  function cartesianTriangleArea(triangle) {\n    var a = triangle[0], b = triangle[1], c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n  }\n\n  function compareArea(a, b) {\n    return a[1][2] - b[1][2];\n  }\n\n  function minAreaHeap() {\n    var heap = {},\n        array = [],\n        size = 0;\n\n    heap.push = function(object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n\n    heap.pop = function() {\n      if (size <= 0) return;\n      var removed = array[0], object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n\n    heap.remove = function(removed) {\n      var i = removed._, object;\n      if (array[i] !== removed) return; // invalid request\n      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n\n    function up(object, i) {\n      while (i > 0) {\n        var j = ((i + 1) >> 1) - 1,\n            parent = array[j];\n        if (compareArea(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    function down(object, i) {\n      while (true) {\n        var r = (i + 1) << 1,\n            l = r - 1,\n            j = i,\n            child = array[j];\n        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];\n        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    return heap;\n  }\n\n  function transformAbsolute(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      point[0] = (x0 += point[0]) * kx + dx;\n      point[1] = (y0 += point[1]) * ky + dy;\n    };\n  }\n\n  function transformRelative(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      var x1 = (point[0] - dx) / kx | 0,\n          y1 = (point[1] - dy) / ky | 0;\n      point[0] = x1 - x0;\n      point[1] = y1 - y0;\n      x0 = x1;\n      y0 = y1;\n    };\n  }\n\n  function noop() {}\n\n  if (typeof define === \"function\" && define.amd) define(topojson);\n  else if (typeof module === \"object\" && module.exports) module.exports = topojson;\n  else this.topojson = topojson;\n}();\n",
    "var DEPS = require('./Dependencies').ALL;\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.dirty = a ? a.dirty : [];\n  b.request = a ? a.request : null;\n  for (var d, i=0, n=DEPS.length; i<n; ++i) {\n    b[d=DEPS[i]] = a ? a[d] : {};\n  }\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy\n};",
    "var log = require('vega-logging'),\n    Tuple = require('./Tuple'),\n    Base = require('./Node').prototype,\n    ChangeSet = require('./ChangeSet');\n\nfunction Collector(graph) {\n  Base.init.call(this, graph);\n  this._data = [];\n  this.router(true).collector(true);\n}\n\nvar prototype = (Collector.prototype = Object.create(Base));\nprototype.constructor = Collector;\n\nprototype.data = function() {\n  return this._data;\n};\n\nprototype.evaluate = function(input) {\n  log.debug(input, [\"collecting\"]);\n\n  // Create a new output changeset to prevent pollution when the Graph\n  // merges reflow and regular changesets.\n  var output = ChangeSet.create(input);\n\n  if (input.rem.length) {\n    this._data = Tuple.idFilter(this._data, input.rem);\n    output.rem = input.rem.slice(0);\n  }\n\n  if (input.add.length) {\n    this._data = this._data.concat(input.add);\n    output.add = input.add.slice(0);\n  }\n\n  if (input.mod.length) {\n    output.mod = input.mod.slice(0);\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  if (input.reflow) {\n    output.mod = output.mod.concat(\n      Tuple.idFilter(this._data, output.add, output.mod, output.rem));\n    output.reflow = false;\n  }\n\n  return output;\n};\n\nmodule.exports = Collector;",
    "var log = require('vega-logging'),\n    ChangeSet = require('./ChangeSet'), \n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Node = require('./Node'); // jshint ignore:line\n\nfunction DataSource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet  = facet;\n  this._input  = ChangeSet.create();\n  this._output = null; // Output changeset\n\n  this._inputNode  = null;\n  this._outputNode = null;\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline.\n  this._mutates = false;  // Does any pipeline operator mutate tuples?\n}\n\nvar prototype = DataSource.prototype;\n\nprototype.name = function(name) {\n  if (!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nprototype.source = function(src) {\n  if (!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nprototype.insert = function(tuples) {\n  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));\n  return this;\n};\n\nprototype.remove = function(where) {\n  var remove = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(remove);\n  return this;\n};\n\nprototype.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = Tuple.idMap(mod);\n\n  this._input.fields[field] = 1;\n\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      Tuple.set(x, field, next);\n      if (ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n\n  return this;\n};\n\nprototype.values = function(data) {\n  if (!arguments.length) return this._collector.data();\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nprototype.mutates = function(m) {\n  if (!arguments.length) return this._mutates;\n  this._mutates = this._mutates || m;\n  return this;\n};\n\nprototype.last = function() {\n  return this._output;\n};\n\nprototype.fire = function(input) {\n  if (input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nprototype.pipeline = function(pipeline) {\n  if (!arguments.length) return this._pipeline;\n\n  var graph = this._graph,\n      status;\n\n  pipeline.unshift(this._inputNode = DataSourceInput(this));\n  status = graph.preprocess(pipeline);\n\n  if (status.router) {\n    pipeline.push(status.collector = new Collector(graph));\n  }\n\n  pipeline.push(this._outputNode = DataSourceOutput(this));\n  this._collector = status.collector;\n  this._mutates = !!status.mutates;\n  graph.connect(this._pipeline = pipeline);\n\n  return this;\n};\n\nprototype.synchronize = function() {\n  this._graph.synchronize(this._pipeline);\n  return this;\n};\n\nprototype.listener = function() { \n  return DataSourceListener(this).addListener(this._inputNode);\n};\n\nprototype.addListener = function(l) {\n  if (l instanceof DataSource) {\n    this._collector.addListener(l.listener());\n  } else {\n    this._outputNode.addListener(l);      \n  }\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  this._outputNode.removeListener(l);\n};\n\nprototype.listeners = function(ds) {\n  return (ds ? this._collector : this._outputNode).listeners();\n};\n\n// Input node applies the datasource's delta, and propagates it to \n// the rest of the pipeline. It receives touches to reflow data.\nfunction DataSourceInput(ds) {\n  var input = new Node(ds._graph)\n    .router(true)\n    .collector(true);\n\n  input.data = function() {\n    return ds._data;\n  };\n\n  input.evaluate = function(input) {\n    log.debug(input, ['input', ds._name]);\n\n    var delta = ds._input, \n        out = ChangeSet.create(input), f;\n\n    // Delta might contain fields updated through API\n    for (f in delta.fields) {\n      out.fields[f] = 1;\n    }\n\n    // update data\n    if (delta.rem.length) {\n      ds._data = Tuple.idFilter(ds._data, delta.rem);\n    }\n\n    if (delta.add.length) {\n      ds._data = ds._data.concat(delta.add);\n    }\n\n    if (delta.sort) {\n      ds._data.sort(delta.sort);\n    }\n\n    // if reflowing, add any other tuples not currently in changeset\n    if (input.reflow) {\n      delta.mod = delta.mod.concat(\n        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));\n    }\n\n    // reset change list\n    ds._input = ChangeSet.create();\n\n    out.add = delta.add; \n    out.mod = delta.mod;\n    out.rem = delta.rem;\n    out.facet = ds._facet;\n    return out;\n  };\n\n  return input;\n}\n\n// Output node captures the last changeset seen by this datasource\n// (needed for joins and builds) and materializes any nested data.\n// If this datasource is faceted, materializes the values in the facet.\nfunction DataSourceOutput(ds) {\n  var output = new Node(ds._graph)\n    .router(true)\n    .reflows(true)\n    .collector(true);\n\n  output.data = function() {\n    return ds._collector ? ds._collector.data() : ds._data;\n  };\n\n  output.evaluate = function(input) {\n    log.debug(input, ['output', ds._name]);\n\n    var out = ChangeSet.create(input, true);\n\n    if (ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    out.data[ds._name] = 1;\n    return out;\n  };\n\n  return output;\n}\n\nfunction DataSourceListener(ds) {\n  var l = new Node(ds._graph).router(true);\n\n  l.evaluate = function(input) {\n    // Tuple derivation carries a cost. So only derive if the pipeline has\n    // operators that mutate, and thus would override the source data.\n    if (ds.mutates()) {  \n      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly\n          output = ChangeSet.create(input);\n\n      output.add = input.add.map(function(t) {\n        return (map[t._id] = Tuple.derive(t));\n      });\n\n      output.mod = input.mod.map(function(t) {\n        return Tuple.rederive(t, map[t._id]);\n      });\n\n      output.rem = input.rem.map(function(t) { \n        var o = map[t._id];\n        return (map[t._id] = null, o);\n      });\n\n      return (ds._input = output);\n    } else {\n      return (ds._input = input);\n    }\n  };\n\n  return l;\n}\n\nmodule.exports = DataSource;\n",
    "var deps = module.exports = {\n  ALL: ['data', 'fields', 'scales', 'signals']\n};\ndeps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });\n",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    Heap = require('./Heap'),\n    ChangeSet = require('./ChangeSet'),\n    DataSource = require('./DataSource'),\n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Signal = require('./Signal'),\n    Deps = require('./Dependencies');\n\nfunction Graph() {\n}\n\nvar prototype = Graph.prototype;\n\nprototype.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nprototype.rank = function() {\n  return ++this._rank;\n};\n\nprototype.values = function(type, names, hash) {\n  var data = (type === Deps.SIGNALS ? this._signals : this._data),\n      n = (names !== undefined ? names : dl.keys(data)),\n      vals, i;\n\n  if (Array.isArray(n)) {\n    vals = hash || {};\n    for (i=0; i<n.length; ++i) {\n      vals[n[i]] = data[n[i]].values();\n    }\n    return vals;\n  } else {\n    return data[n].values();\n  }\n};\n\n// Retain for backwards-compatibility\nprototype.dataValues = function(names) {\n  return this.values(Deps.DATA, names);\n};\n\n// Retain for backwards-compatibility\nprototype.signalValues = function(names) {\n  return this.values(Deps.SIGNALS, names);\n};\n\nprototype.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if (!arguments.length) {\n    var all = [], key;\n    for (key in db) { all.push(db[key]); }\n    return all;\n  } else if (arguments.length === 1) {\n    return db[name];\n  } else {\n    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));\n  }\n};\n\nprototype.signal = function(name, init) {\n  if (arguments.length === 1) {\n    var m = this;\n    return Array.isArray(name) ?\n      name.map(function(n) { return m._signals[n]; }) :\n      this._signals[name];\n  } else {\n    return (this._signals[name] = new Signal(this, name, init));\n  }\n};\n\nprototype.signalRef = function(ref) {\n  if (!Array.isArray(ref)) {\n    ref = dl.field(ref);\n  }\n\n  var value = this.signal(ref[0]).value();\n  if (ref.length > 1) {\n    for (var i=1, n=ref.length; i<n; ++i) {\n      value = value[ref[i]];\n    }\n  }\n  return value;\n};\n\n// Stamp should be specified with caution. It is necessary for inline datasources,\n// which need to be populated during the same cycle even though propagation has\n// passed that part of the dataflow graph.  \nprototype.propagate = function(pulse, node, stamp) {\n  var pulses = {},\n      listeners, next, nplse, tpls, ntpls, i, len;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(function(a, b) {\n    // Sort on qrank (queue-rank).\n    // Rank can change during propagation due to rewiring.\n    return a._qrank - b._qrank;\n  });\n\n  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');\n\n  pulse.stamp = stamp || ++this._stamp;\n  pulses[node._id] = pulse;\n  pq.push(node.qrank(true));\n\n  while (pq.size() > 0) {\n    node  = pq.peek();\n    pulse = pulses[node._id];\n\n    if (node.rank() !== node.qrank()) {\n      // A node's rank might change during a propagation. Re-queue if so.\n      pq.replace(node.qrank(true));\n    } else {\n      // Evaluate node and propagate pulse.\n      pq.pop();\n      pulses[node._id] = null;\n      listeners = node._listeners;\n      pulse = this.evaluate(pulse, node);\n\n      // Propagate the pulse. \n      if (pulse !== this.doNotPropagate) {\n        // Ensure reflow pulses always send reflow pulses even if skipped.\n        if (!pulse.reflow && node.reflows()) {\n          pulse = ChangeSet.create(pulse, true);\n        }\n\n        for (i=0, len=listeners.length; i<len; ++i) {\n          next = listeners[i];\n\n          if ((nplse = pulses[next._id]) !== undefined) {\n            if (nplse === null) throw Error('Already propagated to node.');\n            if (nplse === pulse) continue;  // Re-queueing the same pulse.\n\n            // We've already queued this node. Ensure there should be at most one\n            // pulse with tuples (add/mod/rem), and the remainder will be reflows. \n            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;\n            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;\n\n            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');\n\n            // Combine reflow and tuples into a single pulse. \n            pulses[next._id] = tpls ? pulse : nplse;\n            pulses[next._id].reflow = pulse.reflow || nplse.reflow;\n          } else {\n            // First time we're seeing this node, queue it for propagation.\n            pq.push(next.qrank(true));\n            pulses[next._id] = pulse;\n          }\n        }\n      }\n    }\n  }\n\n  return this.done(pulse);\n};\n\n// Perform final bookkeeping on the graph, after propagation is complete. \n//  - For all updated datasources, synchronize their previous values.\nprototype.done = function(pulse) {\n  log.debug(pulse, ['bookkeeping']);\n  for (var d in pulse.data) { this.data(d).synchronize(); }\n  return this;\n};\n\n// Process a new branch of the dataflow graph prior to connection:\n// (1) Insert new Collector nodes as needed. \n// (2) Track + return mutation/routing status of the branch.\nprototype.preprocess = function(branch) {\n  var graph = this,\n      mutates = 0,\n      node, router, collector, collects;\n\n  for (var i=0; i<branch.length; ++i) {\n    node = branch[i];\n\n    // Batch nodes need access to a materialized dataset. \n    if (node.batch() && !node._collector) {\n      if (router || !collector) {\n        node = new Collector(graph);\n        branch.splice(i, 0, node);\n        router = false;\n      } else {\n        node._collector = collector;\n      }\n    }\n\n    if ((collects = node.collector())) collector = node;\n    router  = router  || node.router() && !collects;\n    mutates = mutates || node.mutates();\n\n    // A collector needs to be inserted after tuple-producing\n    // nodes for correct previous value tracking.\n    if (node.produces()) {\n      branch.splice(i+1, 0, new Collector(graph));\n      router = false;\n    }\n  }\n\n  return {router: router, collector: collector, mutates: mutates};\n};\n\nprototype.connect = function(branch) {\n  var collector, node, data, signals, i, n, j, m, x, y;\n\n  // connect the pipeline\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      if (!(x=this.data(y=data[j]))) {\n        throw new Error('Unknown data source ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      if (!(x=this.signal(y=signals[j]))) {\n        throw new Error('Unknown signal ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    if (i > 0) branch[i-1].addListener(node);\n  }\n\n  return branch;\n};\n\nprototype.disconnect = function(branch) {\n  var collector, node, data, signals, i, n, j, m;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      this.data(data[j]).removeListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      this.signal(signals[j]).removeListener(collector);\n    }\n\n    node.disconnect();\n  }\n\n  return branch;\n};\n\nprototype.synchronize = function(branch) {\n  var ids = {},\n      node, data, i, n, j, m, d, id;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (!node.collector()) continue;\n\n    for (j=0, data=node.data(), m=data.length; j<m; ++j) {\n      id = (d = data[j])._id;\n      if (ids[id]) continue; \n      Tuple.prev_update(d);\n      ids[id] = 1; \n    }\n  }\n\n  return this;\n};\n\nprototype.reevaluate = function(pulse, node) {\n  var reflowed = pulse.reflow && node.last() >= pulse.stamp,\n      run = node.router() || pulse.add.length || pulse.rem.length;\n\n  return run || !reflowed || node.reevaluate(pulse);\n};\n\nprototype.evaluate = function(pulse, node) {\n  if (!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse;\n};\n\nmodule.exports = Graph;\n",
    "function Heap(comparator) {\n  this.cmp = comparator;\n  this.nodes = [];\n}\n\nvar prototype = Heap.prototype;\n\nprototype.size = function() {\n  return this.nodes.length;\n};\n\nprototype.clear = function() {\n  return (this.nodes = [], this);\n};\n\nprototype.peek = function() {\n  return this.nodes[0];\n};\n\nprototype.push = function(x) {\n  var array = this.nodes;\n  array.push(x);\n  return _siftdown(array, 0, array.length-1, this.cmp);\n};\n\nprototype.pop = function() {\n  var array = this.nodes,\n      last = array.pop(),\n      item;\n\n  if (array.length) {\n    item = array[0];\n    array[0] = last;\n    _siftup(array, 0, this.cmp);\n  } else {\n    item = last;\n  }\n  return item;\n};\n\nprototype.replace = function(item) {\n  var array = this.nodes,\n      retval = array[0];\n  array[0] = item;\n  _siftup(array, 0, this.cmp);\n  return retval;\n};\n\nprototype.pushpop = function(item) {\n  var array = this.nodes, ref = array[0];\n  if (array.length && this.cmp(ref, item) < 0) {\n    array[0] = item;\n    item = ref;\n    _siftup(array, 0, this.cmp);\n  }\n  return item;\n};\n\nfunction _siftdown(array, start, idx, cmp) {\n  var item, parent, pidx;\n\n  item = array[idx];\n  while (idx > start) {\n    pidx = (idx - 1) >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\nfunction _siftup(array, idx, cmp) {\n  var start = idx,\n      end = array.length,\n      item = array[idx],\n      cidx = 2 * idx + 1, ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = 2 * idx + 1;\n  }\n  array[idx] = item;\n  return _siftdown(array, start, idx, cmp);\n}\n\nmodule.exports = Heap;\n",
    "var DEPS = require('./Dependencies').ALL,\n    nodeID = 0;\n\nfunction Node(graph) {\n  if (graph) this.init(graph);\n}\n\nvar Flags = Node.Flags = {\n  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.\n  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.\n  Produces:   0x04, // Produces new tuples. \n  Mutates:    0x08, // Sets properties of incoming tuples.\n  Reflows:    0x10, // Forwards a reflow pulse.\n  Batch:      0x20  // Performs batch data processing, needs collector.\n};\n\nvar prototype = Node.prototype;\n\nprototype.init = function(graph) {\n  this._id = ++nodeID;\n  this._graph = graph;\n  this._rank  = graph.rank(); // Topological sort by rank\n  this._qrank = null; // Rank when enqueued for propagation\n  this._stamp = 0;    // Last stamp seen\n\n  this._listeners = [];\n  this._listeners._ids = {}; // To prevent duplicate listeners\n\n  // Initialize dependencies.\n  this._deps = {};\n  for (var i=0, n=DEPS.length; i<n; ++i) {\n    this._deps[DEPS[i]] = [];\n  }\n\n  // Initialize status flags.\n  this._flags = 0;\n\n  return this;\n};\n\nprototype.rank = function() {\n  return this._rank;\n};\n\nprototype.rerank = function() {\n  var g = this._graph, \n      q = [this],\n      cur;\n\n  while (q.length) {\n    cur = q.shift();\n    cur._rank = g.rank();\n    q.unshift.apply(q, cur.listeners());\n  }\n\n  return this;\n};\n\nprototype.qrank = function(/* set */) {\n  if (!arguments.length) return this._qrank;\n  return (this._qrank = this._rank, this);\n};\n\nprototype.last = function(stamp) { \n  if (!arguments.length) return this._stamp;\n  return (this._stamp = stamp, this);\n};\n\n// -- status flags ---\n\nprototype._setf = function(v, b) {\n  if (b) { this._flags |= v; } else { this._flags &= ~v; }\n  return this;\n};\n\nprototype.router = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Router);\n  return this._setf(Flags.Router, state);\n};\n\nprototype.collector = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Collector);\n  return this._setf(Flags.Collector, state);\n};\n\nprototype.produces = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Produces);\n  return this._setf(Flags.Produces, state);\n};\n\nprototype.mutates = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Mutates);\n  return this._setf(Flags.Mutates, state);\n};\n\nprototype.reflows = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Reflows);\n  return this._setf(Flags.Reflows, state);\n};\n\nprototype.batch = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Batch);\n  return this._setf(Flags.Batch, state);\n};\n\nprototype.dependency = function(type, deps) {\n  var d = this._deps[type],\n      n = d._names || (d._names = {});  // To prevent dupe deps\n\n  // Get dependencies of the given type\n  if (arguments.length === 1) {\n    return d;\n  }\n\n  if (deps === null) {\n    // Clear dependencies of the given type\n    d.splice(0, d.length);\n    d._names = {};\n  } else if (!Array.isArray(deps)) {\n    // Separate this case to avoid cost of array creation\n    if (n[deps]) return this;\n    d.push(deps);\n    n[deps] = 1;\n  } else {\n    for (var i=0, len=deps.length, dep; i<len; ++i) {\n      dep = deps[i];\n      if (n[dep]) continue;\n      d.push(dep);\n      n[dep] = 1;\n    }\n  }\n\n  return this;\n};\n\nprototype.listeners = function() {\n  return this._listeners;\n};\n\nprototype.addListener = function(l) {\n  if (!(l instanceof Node)) {\n    throw Error('Listener is not a Node');\n  }\n  if (this._listeners._ids[l._id]) return this;\n\n  this._listeners.push(l);\n  this._listeners._ids[l._id] = 1;\n  if (this._rank > l._rank) {\n    l.rerank();\n  }\n\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  if (!this._listeners._ids[l._id]) return false;\n  \n  var idx = this._listeners.indexOf(l),\n      b = idx >= 0;\n\n  if (b) {\n    this._listeners.splice(idx, 1);\n    this._listeners._ids[l._id] = null;\n  }\n  return b;\n};\n\nprototype.disconnect = function() {\n  this._listeners = [];\n  this._listeners._ids = {};\n};\n\n// Evaluate this dataflow node for the current pulse.\n// Subclasses should override to perform custom processing.\nprototype.evaluate = function(pulse) {\n  return pulse;\n};\n\n// Should this node be re-evaluated for the current pulse?\n// Searches pulse to see if any dependencies have updated.\nprototype.reevaluate = function(pulse) {\n  var prop, dep, i, n, j, m;\n\n  for (i=0, n=DEPS.length; i<n; ++i) {\n    prop = DEPS[i];\n    dep = this._deps[prop];\n    for (j=0, m=dep.length; j<m; ++j) {\n      if (pulse[prop][dep[j]]) return true;\n    }\n  }\n\n  return false;\n};\n\nNode.reset = function() { nodeID = 0; };\n\nmodule.exports = Node;\n",
    "var ChangeSet = require('./ChangeSet'),\n    Node = require('./Node'), // jshint ignore:line\n    Base = Node.prototype;\n\nfunction Signal(graph, name, initialValue) {\n  Base.init.call(this, graph);\n  this._name  = name;\n  this._value = initialValue;\n  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.\n  this._handlers = [];\n  return this;\n}\n\nvar prototype = (Signal.prototype = Object.create(Base));\nprototype.constructor = Signal;\n\nprototype.name = function() {\n  return this._name;\n};\n\nprototype.value = function(val) {\n  if (!arguments.length) return this._value;\n  return (this._value = val, this);\n};\n\n// Alias to value, for shared API with DataSource\nprototype.values = prototype.value;\n\nprototype.verbose = function(v) {\n  if (!arguments.length) return this._verbose;\n  return (this._verbose = !!v, this);\n};\n\nprototype.evaluate = function(input) {\n  return input.signals[this._name] ? input : this._graph.doNotPropagate;\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nprototype.on = function(handler) {\n  var signal = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    handler(signal.name(), signal.value());\n    return input;\n  };\n\n  this._handlers.push({\n    handler: handler,\n    node: node\n  });\n\n  return this.addListener(node);\n};\n\nprototype.off = function(handler) {\n  var h = this._handlers, i, x;\n\n  for (i=h.length; --i>=0;) {\n    if (!handler || h[i].handler === handler) {\n      x = h.splice(i, 1)[0];\n      this.removeListener(x.node);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = Signal;\n",
    "var tupleID = 0;\n\nfunction ingest(datum) {\n  datum = (datum === Object(datum)) ? datum : {data: datum};\n  datum._id = ++tupleID;\n  if (datum._prev) datum._prev = null;\n  return datum;\n}\n\nfunction idMap(a, ids) {\n  ids = ids || {};\n  for (var i=0, n=a.length; i<n; ++i) {\n    ids[a[i]._id] = 1;\n  }\n  return ids;\n}\n\nfunction copy(t, c) {\n  c = c || {};\n  for (var k in t) {\n    if (k !== '_prev' && k !== '_id') c[k] = t[k];\n  }\n  return c;\n}\n\nmodule.exports = {\n  ingest: ingest,\n  idMap: idMap,\n\n  derive: function(d) {\n    return ingest(copy(d));\n  },\n\n  rederive: function(d, t) {\n    return copy(d, t);\n  },\n\n  set: function(t, k, v) {\n    return t[k] === v ? 0 : (t[k] = v, 1);\n  },\n\n  prev: function(t) {\n    return t._prev || t;\n  },\n\n  prev_init: function(t) {\n    if (!t._prev) { t._prev = {_id: t._id}; }\n  },\n\n  prev_update: function(t) {\n    var p = t._prev, k, v;\n    if (p) for (k in t) {\n      if (k !== '_prev' && k !== '_id') {\n        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;\n      }\n    }\n  },\n\n  reset: function() { tupleID = 0; },\n\n  idFilter: function(data) {\n    var ids = {};\n    for (var i=arguments.length; --i>0;) {\n      idMap(arguments[i], ids);\n    }\n    return data.filter(function(x) { return !ids[x._id]; });\n  }\n};\n",
    "module.exports = {\n  ChangeSet:    require('./ChangeSet'),\n  Collector:    require('./Collector'),\n  DataSource:   require('./DataSource'),\n  Dependencies: require('./Dependencies'),\n  Graph:        require('./Graph'),\n  Node:         require('./Node'),\n  Signal:       require('./Signal'),\n  Tuple:        require('./Tuple'),\n  debug:        require('vega-logging').debug\n};\n",
    "function toMap(list) {\n  var map = {}, i, n;\n  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;\n  return map;\n}\n\nfunction keys(object) {\n  var list = [], k;\n  for (k in object) list.push(k);\n  return list;\n}\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants'),\n      functions = (opt.functions || require('./functions'))(codegen),\n      functionDefs = opt.functionDefs ? opt.functionDefs(codegen) : {},\n      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,\n      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,\n      memberDepth = 0,\n      FIELD_VAR = opt.fieldVar || 'datum',\n      GLOBAL_VAR = opt.globalVar || 'signals',\n      globals = {},\n      fields = {};\n\n  function codegen_wrap(ast) {\n    var retval = {\n      code: codegen(ast),\n      globals: keys(globals),\n      fields: keys(fields),\n      defs: functionDefs\n    };\n    globals = {};\n    fields = {};\n    return retval;\n  }\n\n  /* istanbul ignore next */\n  var lookupGlobal = typeof GLOBAL_VAR === 'function' ? GLOBAL_VAR :\n    function (id) {\n      return GLOBAL_VAR + '[\"' + id + '\"]';\n    };\n\n  function codegen(ast) {\n    if (typeof ast === 'string') return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error('Unsupported type: ' + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    'Literal': function(n) {\n        return n.raw;\n      },\n    'Identifier': function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            globals[id] = 1;\n            return lookupGlobal(id);\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error('Illegal identifier: ' + id);\n        }\n        return id;\n      },\n    'Program': function(n) {\n        return n.body.map(codegen).join('\\n');\n      },\n    'MemberExpression': function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? '.'+p : '['+p+']');\n      },\n    'CallExpression': function(n) {\n        if (n.callee.type !== 'Identifier') {\n          throw new Error('Illegal callee type: ' + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error('Unrecognized function: ' + callee);\n        return fn instanceof Function ?\n          fn(args) :\n          fn + '(' + args.map(codegen).join(',') + ')';\n      },\n    'ArrayExpression': function(n) {\n        return '[' + n.elements.map(codegen).join(',') + ']';\n      },\n    'BinaryExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'UnaryExpression': function(n) {\n        return '(' + n.operator + codegen(n.argument) + ')';\n      },\n    'ConditionalExpression': function(n) {\n        return '(' + codegen(n.test) +\n          '?' + codegen(n.consequent) +\n          ':' + codegen(n.alternate) +\n          ')';\n      },\n    'LogicalExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'ObjectExpression': function(n) {\n        return '{' + n.properties.map(codegen).join(',') + '}';\n      },\n    'Property': function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + ':' + codegen(n.value);\n      },\n    'ExpressionStatement': function(n) {\n        return codegen(n.expression);\n      }\n  };\n\n  codegen_wrap.functions = functions;\n  codegen_wrap.functionDefs = functionDefs;\n  codegen_wrap.constants = constants;\n  return codegen_wrap;\n};",
    "module.exports = {\n  'NaN':     'NaN',\n  'E':       'Math.E',\n  'LN2':     'Math.LN2',\n  'LN10':    'Math.LN10',\n  'LOG2E':   'Math.LOG2E',\n  'LOG10E':  'Math.LOG10E',\n  'PI':      'Math.PI',\n  'SQRT1_2': 'Math.SQRT1_2',\n  'SQRT2':   'Math.SQRT2'\n};",
    "module.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ?\n      '()' :\n      '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return function(args) {\n      return fncall(name, args, cast, type);\n    };\n  }\n\n  var DATE = 'new Date',\n      STRING = 'String',\n      REGEXP = 'RegExp';\n\n  return {\n    // MATH functions\n    'isNaN':    'isNaN',\n    'isFinite': 'isFinite',\n    'abs':      'Math.abs',\n    'acos':     'Math.acos',\n    'asin':     'Math.asin',\n    'atan':     'Math.atan',\n    'atan2':    'Math.atan2',\n    'ceil':     'Math.ceil',\n    'cos':      'Math.cos',\n    'exp':      'Math.exp',\n    'floor':    'Math.floor',\n    'log':      'Math.log',\n    'max':      'Math.max',\n    'min':      'Math.min',\n    'pow':      'Math.pow',\n    'random':   'Math.random',\n    'round':    'Math.round',\n    'sin':      'Math.sin',\n    'sqrt':     'Math.sqrt',\n    'tan':      'Math.tan',\n\n    'clamp': function(args) {\n      if (args.length < 3)\n        throw new Error('Missing arguments to clamp function.');\n      if (args.length > 3)\n        throw new Error('Too many arguments to clamp function.');\n      var a = args.map(codegen);\n      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';\n    },\n\n    // DATE functions\n    'now':             'Date.now',\n    'utc':             'Date.UTC',\n    'datetime':        DATE,\n    'date':            fn('getDate', DATE, 0),\n    'day':             fn('getDay', DATE, 0),\n    'year':            fn('getFullYear', DATE, 0),\n    'month':           fn('getMonth', DATE, 0),\n    'hours':           fn('getHours', DATE, 0),\n    'minutes':         fn('getMinutes', DATE, 0),\n    'seconds':         fn('getSeconds', DATE, 0),\n    'milliseconds':    fn('getMilliseconds', DATE, 0),\n    'time':            fn('getTime', DATE, 0),\n    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),\n    'utcdate':         fn('getUTCDate', DATE, 0),\n    'utcday':          fn('getUTCDay', DATE, 0),\n    'utcyear':         fn('getUTCFullYear', DATE, 0),\n    'utcmonth':        fn('getUTCMonth', DATE, 0),\n    'utchours':        fn('getUTCHours', DATE, 0),\n    'utcminutes':      fn('getUTCMinutes', DATE, 0),\n    'utcseconds':      fn('getUTCSeconds', DATE, 0),\n    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),\n\n    // shared sequence functions\n    'length':      fn('length', null, -1),\n    'indexof':     fn('indexOf', null),\n    'lastindexof': fn('lastIndexOf', null),\n\n    // STRING functions\n    'parseFloat':  'parseFloat',\n    'parseInt':    'parseInt',\n    'upper':       fn('toUpperCase', STRING, 0),\n    'lower':       fn('toLowerCase', STRING, 0),\n    'slice':       fn('slice', STRING),\n    'substring':   fn('substring', STRING),\n    'replace':     fn('replace', STRING),\n\n    // REGEXP functions\n    'regexp':  REGEXP,\n    'test':    fn('test', REGEXP),\n\n    // Control Flow functions\n    'if': function(args) {\n        if (args.length < 3)\n          throw new Error('Missing arguments to if function.');\n        if (args.length > 3)\n          throw new Error('Too many arguments to if function.');\n        var a = args.map(codegen);\n        return a[0]+'?'+a[1]+':'+a[2];\n      }\n  };\n};\n",
    "var parser = require('./parser'),\n    codegen = require('./codegen');\n\nvar expr = module.exports = {\n  parse: function(input, opt) {\n      return parser.parse('('+input+')', opt);\n    },\n  code: function(opt) {\n      return codegen(opt);\n    },\n  compiler: function(args, opt) {\n      args = args.slice();\n      var generator = codegen(opt),\n          len = args.length,\n          compile = function(str) {\n            var value = generator(expr.parse(str));\n            args[len] = '\"use strict\"; return (' + value.code + ');';\n            var fn = Function.apply(null, args);\n            value.fn = (args.length > 8) ?\n              function() { return fn.apply(value, arguments); } :\n              function(a, b, c, d, e, f, g) {\n                return fn.call(value, a, b, c, d, e, f, g);\n              }; // call often faster than apply, use if args low enough\n            return value;\n          };\n      compile.codegen = generator;\n      return compile;\n    },\n  functions: require('./functions'),\n  constants: require('./constants')\n};",
    "/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* istanbul ignore next */\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();",
    "var ts = Date.now();\n\nfunction write(msg) {\n  msg = '[Vega Log] ' + msg;\n  console.log(msg);\n}\n\nfunction error(msg) {\n  msg = '[Vega Err] ' + msg;\n  console.error(msg);\n}\n\nfunction debug(input, args) {\n  if (!debug.enable) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  var state = {\n    prevTime:  Date.now() - ts,\n    stamp: input.stamp\n  };\n\n  if (input.add) {\n    state.add = input.add.length;\n    state.mod = input.mod.length;\n    state.rem = input.rem.length;\n    state.reflow = !!input.reflow;\n  }\n\n  log.apply(console, (args.push(JSON.stringify(state)), args));\n  ts = Date.now();\n}\n\nmodule.exports = {\n  log:   write,\n  error: error,\n  debug: (debug.enable = false, debug)\n};\n",
    "module.exports = {\n  path:       require('./path'),\n  render:     require('./render'),\n  Item:       require('./util/Item'),\n  bound:      require('./util/bound'),\n  Bounds:     require('./util/Bounds'),\n  canvas:     require('./util/canvas'),\n  Gradient:   require('./util/Gradient'),\n  toJSON:     require('./util/scene').toJSON,\n  fromJSON:   require('./util/scene').fromJSON\n};",
    "var segmentCache = {},\n    bezierCache = {},\n    join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  var key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep === 1){\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segs; ++i) {\n    var th2 = th0 + i * th_arc / segs;\n    var th3 = th0 + (i+1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (segmentCache[key] = result);\n}\n\nfunction bezier(params) {\n  var key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n  \n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (bezierCache[key] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nmodule.exports = {\n  segments: segments,\n  bezier: bezier,\n  cache: {\n    segments: segmentCache,\n    bezier: bezierCache\n  }\n};\n",
    "module.exports = {\n  parse:  require('./parse'),\n  render: require('./render')\n};\n",
    "// Path parsing and rendering code adapted from fabric.js -- Thanks!\nvar cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)([-+])/g, /\\s|,|###/];\n\nmodule.exports = function(pathstr) {\n  var result = [],\n      path,\n      curr,\n      chunks,\n      parsed, param,\n      cmd, len, i, j, n, m;\n\n  // First, break path into command sequence\n  path = pathstr\n    .slice()\n    .replace(regexp[0], '###$1')\n    .split(regexp[1])\n    .slice(1);\n\n  // Next, parse each command in turn\n  for (i=0, n=path.length; i<n; ++i) {\n    curr = path[i];\n    chunks = curr\n      .slice(1)\n      .trim()\n      .replace(regexp[2],'$1###$2')\n      .split(regexp[3]);\n    cmd = curr.charAt(0);\n\n    parsed = [cmd];\n    for (j=0, m=chunks.length; j<m; ++j) {\n      if ((param = +chunks[j]) === param) { // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n    if (parsed.length-1 > len) {\n      for (j=1, m=parsed.length; j<m; j+=len) {\n        result.push([cmd].concat(parsed.slice(j, j+len)));\n      }\n    }\n    else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n};\n",
    "var arc = require('./arc');\n\nmodule.exports = function(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n};\n\nfunction drawArc(g, x, y, coords) {\n  var seg = arc.segments(\n    coords[5], // end x\n    coords[6], // end y\n    coords[0], // radius x\n    coords[1], // radius y\n    coords[3], // large flag\n    coords[4], // sweep flag\n    coords[2], // rotation\n    x, y\n  );\n  for (var i=0; i<seg.length; ++i) {\n    var bez = arc.bezier(seg[i]);\n    g.bezierCurveTo.apply(g, bez);\n  }\n}\n",
    "function Handler() {\n  this._active = null;\n  this._handlers = {};\n}\n\nvar prototype = Handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = el;\n  this._obj = obj || null;\n  return this.padding(pad);\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  return this;\n};\n\nprototype.scene = function(scene) {\n  if (!arguments.length) return this._scene;\n  this._scene = scene;\n  return this;\n};\n\n// add an event handler\n// subclasses should override\nprototype.on = function(/*type, handler*/) {};\n\n// remove an event handler\n// subclasses should override\nprototype.off = function(/*type, handler*/) {};\n\n// return an array with all registered event handlers\nprototype.handlers = function() {\n  var h = this._handlers, a = [], k;\n  for (k in h) { a.push.apply(a, h[k]); }\n  return a;\n};\n\nprototype.eventName = function(name) {\n  var i = name.indexOf('.');\n  return i < 0 ? name : name.slice(0,i);\n};\n\nmodule.exports = Handler;",
    "function Renderer() {\n  this._el = null;\n  this._bgcolor = null;\n}\n\nvar prototype = Renderer.prototype;\n\nprototype.initialize = function(el, width, height, padding) {\n  this._el = el;\n  return this.resize(width, height, padding);\n};\n\n// Returns the parent container element for a visualization\nprototype.element = function() {\n  return this._el;\n};\n\n// Returns the scene element (e.g., canvas or SVG) of the visualization\n// Subclasses must override if the first child is not the scene element\nprototype.scene = function() {\n  return this._el && this._el.firstChild;\n};\n\nprototype.background = function(bgcolor) {\n  if (arguments.length === 0) return this._bgcolor;\n  this._bgcolor = bgcolor;\n  return this;\n};\n\nprototype.resize = function(width, height, padding) {\n  this._width = width;\n  this._height = height;\n  this._padding = padding || {top:0, left:0, bottom:0, right:0};\n  return this;\n};\n\nprototype.render = function(/*scene, items*/) {\n  return this;\n};\n\nmodule.exports = Renderer;",
    "var DOM = require('../../util/dom'),\n    Handler = require('../Handler'),\n    marks = require('./marks');\n\nfunction CanvasHandler() {\n  Handler.call(this);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n}\n\nvar base = Handler.prototype;\nvar prototype = (CanvasHandler.prototype = Object.create(base));\nprototype.constructor = CanvasHandler;\n\nprototype.initialize = function(el, pad, obj) {\n  // add event listeners\n  var canvas = this._canvas = DOM.find(el, 'canvas');\n  if (canvas) {\n    var that = this;\n    this.events.forEach(function(type) {\n      canvas.addEventListener(type, function(evt) {\n        if (prototype[type]) {\n          prototype[type].call(that, evt);\n        } else {\n          that.fire(type, evt);\n        }\n      });\n    });\n  }\n\n  return base.initialize.call(this, el, pad, obj);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext('2d');\n};\n\n// supported events\nprototype.events = [\n  'keydown',\n  'keypress',\n  'keyup',\n  'mousedown',\n  'mouseup',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'click',\n  'dblclick',\n  'wheel',\n  'mousewheel',\n  'touchstart',\n  'touchmove',\n  'touchend'\n];\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire('mousewheel', evt);\n};\n\nprototype.mousemove = function(evt) {\n  var a = this._active,\n      p = this.pickEvent(evt);\n\n  if (p === a) {\n    // active item and picked item are the same\n    this.fire('mousemove', evt); // fire move\n  } else {\n    // active item and picked item are different\n    this.fire('mouseout', evt);  // fire out for prior active item\n    this._active = p;            // set new active item\n    this.fire('mouseover', evt); // fire over for new active item\n    this.fire('mousemove', evt); // fire move for new active item\n  }\n};\n\nprototype.mouseout = function(evt) {\n  this.fire('mouseout', evt);\n  this._active = null;\n};\n\nprototype.mousedown = function(evt) {\n  this._down = this._active;\n  this.fire('mousedown', evt);\n};\n\nprototype.click = function(evt) {\n  if (this._down === this._active) {\n    this.fire('click', evt);\n    this._down = null;\n  }\n};\n\nprototype.touchstart = function(evt) {\n  this._touch = this.pickEvent(evt.changedTouches[0]);\n\n  if (this._first) {\n    this._active = this._touch;\n    this._first = false;\n  }\n\n  this.fire('touchstart', evt, true);\n};\n\nprototype.touchmove = function(evt) {\n  this.fire('touchmove', evt, true);\n};\n\nprototype.touchend = function(evt) {\n  this.fire('touchend', evt, true);\n  this._touch = null;\n};\n\n// fire an event\nprototype.fire = function(type, evt, touch) {\n  var a = touch ? this._touch : this._active,\n      h = this._handlers[type], i, len;\n  if (h) {\n    evt.vegaType = type;\n    for (i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers;\n  (h[name] || (h[name] = [])).push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers[name], i;\n  if (!h) return;\n  for (i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\nprototype.pickEvent = function(evt) {\n  var rect = this._canvas.getBoundingClientRect(),\n      pad = this._padding, x, y;\n  return this.pick(this._scene,\n    x = (evt.clientX - rect.left),\n    y = (evt.clientY - rect.top),\n    x - pad.left, y - pad.top);\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      mark = marks[scene.marktype];\n  return mark.pick.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = CanvasHandler;\n",
    "var DOM = require('../../util/dom'),\n    Bounds = require('../../util/Bounds'),\n    ImageLoader = require('../../util/ImageLoader'),\n    Canvas = require('../../util/canvas'),\n    Renderer = require('../Renderer'),\n    marks = require('./marks');\n\nfunction CanvasRenderer(loadConfig) {\n  Renderer.call(this);\n  this._loader = new ImageLoader(loadConfig);\n}\n\nCanvasRenderer.RETINA = true;\n\nvar base = Renderer.prototype;\nvar prototype = (CanvasRenderer.prototype = Object.create(base));\nprototype.constructor = CanvasRenderer;\n\nprototype.initialize = function(el, width, height, padding) {\n  this._canvas = Canvas.instance(width, height);\n  if (el) {\n    DOM.clear(el, 0).appendChild(this._canvas);\n    this._canvas.setAttribute('class', 'marks');\n  }\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  Canvas.resize(this._canvas, this._width, this._height,\n    this._padding, CanvasRenderer.RETINA);\n  return this;\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.context = function() {\n  return this._canvas ? this._canvas.getContext('2d') : null;\n};\n\nprototype.pendingImages = function() {\n  return this._loader.pending();\n};\n\nfunction clipToBounds(g, items) {\n  if (!items) return null;\n\n  var b = new Bounds(), i, n, item, mark, group;\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    mark = item.mark;\n    group = mark.group;\n    item = marks[mark.marktype].nested ? mark : item;\n    b.union(translate(item.bounds, group));\n    if (item['bounds:prev']) {\n      b.union(translate(item['bounds:prev'], group));\n    }\n  }\n  b.round();\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n\n  return b;\n}\n\nfunction translate(bounds, group) {\n  if (group == null) return bounds;\n  var b = bounds.clone();\n  for (; group != null; group = group.mark.group) {\n    b.translate(group.x || 0, group.y || 0);\n  }\n  return b;\n}\n\nprototype.render = function(scene, items) {\n  var g = this.context(),\n      p = this._padding,\n      w = this._width + p.left + p.right,\n      h = this._height + p.top + p.bottom,\n      b;\n\n  // setup\n  this._scene = scene; // cache scene for async redraw\n  g.save();\n  b = clipToBounds(g, items);\n  this.clear(-p.left, -p.top, w, h);\n\n  // render\n  this.draw(g, scene, b);\n  \n  // takedown\n  g.restore();\n  this._scene = null; // clear scene cache\n\n  return this;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var mark = marks[scene.marktype];\n  mark.draw.call(this, ctx, scene, bounds);\n};\n\nprototype.clear = function(x, y, w, h) {\n  var g = this.context();\n  g.clearRect(x, y, w, h);\n  if (this._bgcolor != null) {\n    g.fillStyle = this._bgcolor;\n    g.fillRect(x, y, w, h); \n  }\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = this._scene;\n  return this._loader.loadImage(uri, function() {\n    renderer.renderAsync(scene);\n  });\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 10);\n};\n\nmodule.exports = CanvasRenderer;\n",
    "module.exports = {\n  Handler:  require('./CanvasHandler'),\n  Renderer: require('./CanvasRenderer')\n};",
    "var util = require('./util');\nvar halfpi = Math.PI / 2;\n\nfunction path(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};",
    "var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render'),\n    areaPath = require('../../../util/svg').path.area;\n\nfunction path(g, items) {\n  var o = items[0],\n      p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  render(g, p);\n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  var items = scene.items,\n      b = scene.bounds;\n\n  if (!items || !items.length || b && !b.contains(gx, gy)) {\n    return null;\n  }\n\n  if (g.pixelratio != null && g.pixelratio !== 1) {\n    x *= g.pixelratio;\n    y *= g.pixelratio;\n  }\n  return hit(g, items, x, y) ? items[0] : null;\n}\n\nvar hit = util.testPath(path);\n\nmodule.exports = {\n  draw: util.drawOne(path),\n  pick: pick,\n  nested: true\n};\n",
    "var util = require('./util'),\n    EMPTY = [];\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var groups = scene.items,\n      renderer = this,\n      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;\n\n  for (i=0, n=groups.length; i<n; ++i) {\n    group = groups[i];\n    axes = group.axisItems || EMPTY;\n    items = group.items || EMPTY;\n    legends = group.legendItems || EMPTY;\n    gx = group.x || 0;\n    gy = group.y || 0;\n    w = group.width || 0;\n    h = group.height || 0;\n\n    // draw group background\n    if (group.stroke || group.fill) {\n      opac = group.opacity == null ? 1 : group.opacity;\n      if (opac > 0) {\n        if (group.fill && util.fill(g, group, opac)) {\n          g.fillRect(gx, gy, w, h);\n        }\n        if (group.stroke && util.stroke(g, group, opac)) {\n          g.strokeRect(gx, gy, w, h);\n        }\n      }\n    }\n\n    // setup graphics context\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, w, h);\n      g.clip();\n    }\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].layer === 'back') {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      renderer.draw(g, items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].layer !== 'back') {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return null;\n  }\n\n  var groups = scene.items || EMPTY, subscene,\n      group, axes, items, legends, hits, dx, dy, i, j, b;\n\n  for (i=groups.length; --i>=0;) {\n    group = groups[i];\n\n    // first hit test against bounding box\n    // if a group is clipped, that should be handled by the bounds check.\n    b = group.bounds;\n    if (b && !b.contains(gx, gy)) continue;\n\n    // passed bounds check, so test sub-groups\n    axes = group.axisItems || EMPTY;\n    items = group.items || EMPTY;\n    legends = group.legendItems || EMPTY;\n    dx = (group.x || 0);\n    dy = (group.y || 0);\n\n    g.save();\n    g.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy;\n    for (j=legends.length; --j>=0;) {\n      subscene = legends[j];\n      if (subscene.interactive !== false) {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=axes.length; --j>=0;) {\n      subscene = axes[j];\n      if (subscene.interactive !== false && subscene.layer !== 'back') {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=items.length; --j>=0;) {\n      subscene = items[j];\n      if (subscene.interactive !== false) {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=axes.length; --j>=0;) {\n      subscene = axes[j];\n      if (subscene.interative !== false && subscene.layer === 'back') {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    g.restore();\n\n    if (scene.interactive !== false && (group.fill || group.stroke) &&\n        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {\n      return group;\n    }\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: pick\n};\n",
    "var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x = o.x || 0,\n        y = o.y || 0,\n        w = o.width || (o.image && o.image.width) || 0,\n        h = o.height || (o.image && o.image.height) || 0,\n        opac;\n    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);\n    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick()\n};",
    "module.exports = {\n  arc:    require('./arc'),\n  area:   require('./area'),\n  group:  require('./group'),\n  image:  require('./image'),\n  line:   require('./line'),\n  path:   require('./path'),\n  rect:   require('./rect'),\n  rule:   require('./rule'),\n  symbol: require('./symbol'),\n  text:   require('./text')\n};\n",
    "var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render'),\n    linePath = require('../../../util/svg').path.line;\n    \nfunction path(g, items) {\n  var o = items[0],\n      p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  render(g, p);\n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  var items = scene.items,\n      b = scene.bounds;\n\n  if (!items || !items.length || b && !b.contains(gx, gy)) {\n    return null;\n  }\n\n  if (g.pixelratio != null && g.pixelratio !== 1) {\n    x *= g.pixelratio;\n    y *= g.pixelratio;\n  }\n  return hit(g, items, x, y) ? items[0] : null;\n}\n\nvar hit = util.testPath(path, false);\n\nmodule.exports = {\n  draw: util.drawOne(path),\n  pick: pick,\n  nested: true\n};\n",
    "var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render');\n\nfunction path(g, o) {\n  if (o.path == null) return true;\n  var p = o.pathCache || (o.pathCache = parse(o.path));\n  render(g, p, o.x, o.y);\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};\n",
    "var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    if (o.fill && util.fill(g, o, opac)) {\n      g.fillRect(x, y, w, h);\n    }\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.strokeRect(x, y, w, h);\n    }\n  }\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick()\n};",
    "var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n      \n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.beginPath();\n      g.moveTo(x1, y1);\n      g.lineTo(x2, y2);\n      g.stroke();\n    }\n  }\n}\n\nfunction stroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : 1;\n  g.lineCap   = lc != null ? lc : 'butt';\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\nfunction hit(g, o, x, y) {\n  if (!g.isPointInStroke) return false;\n  stroke(g, o);\n  return g.isPointInStroke(x, y);\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick(hit)\n};\n",
    "var util = require('./util');\n\nvar sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180);\n\nfunction path(g, o) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  g.beginPath();\n\n  if (o.shape == null || o.shape === 'circle') {\n    r = Math.sqrt(size / Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case 'cross':\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case 'diamond':\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case 'square':\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case 'triangle-down':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case 'triangle-up':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};",
    "var Bounds = require('../../../util/Bounds'),\n    textBounds = require('../../../util/bound').text,\n    text = require('../../../util/text'),\n    util = require('./util'),\n    tempBounds = new Bounds();\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x, y, r, t, str;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    str = text.value(o.text);\n    if (!str) continue;\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n\n    g.font = text.font(o);\n    g.textAlign = o.align || 'left';\n\n    x = (o.x || 0);\n    y = (o.y || 0);\n    if ((r = o.radius)) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = y = 0; // reset x, y\n    }\n    x += (o.dx || 0);\n    y += (o.dy || 0) + text.offset(o);\n\n    if (o.fill && util.fill(g, o, opac)) {\n      g.fillText(str, x, y);\n    }\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.strokeText(str, x, y);\n    }\n    if (o.angle) g.restore();\n  }\n}\n\nfunction hit(g, o, x, y, gx, gy) {\n  if (o.fontSize <= 0) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var b = textBounds(o, tempBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      ox = o.x,\n      oy = o.y,\n      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),\n      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);\n\n  return b.contains(px, py);\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick(hit)\n};\n",
    "function drawPathOne(path, g, o, items) {\n  if (path(g, items)) return;\n\n  var opac = o.opacity == null ? 1 : o.opacity;\n  if (opac===0) return;\n\n  if (o.fill && fill(g, o, opac)) { g.fill(); }\n  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (!bounds || bounds.intersects(item.bounds)) {\n      drawPathOne(path, g, item, item);\n    }\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  };\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (!bounds || bounds.intersects(scene.bounds)) {\n      drawPathOne(pathFunc, g, scene.items[0], scene.items);\n    }\n  };\n}\n\nvar trueFunc = function() { return true; };\n\nfunction pick(test) {\n  if (!test) test = trueFunc;\n\n  return function(g, scene, x, y, gx, gy) {\n    if (!scene.items.length) return null;\n\n    var o, b, i;\n\n    if (g.pixelratio != null && g.pixelratio !== 1) {\n      x *= g.pixelratio;\n      y *= g.pixelratio;\n    }\n\n    for (i=scene.items.length; --i >= 0;) {\n      o = scene.items[i]; b = o.bounds;\n      // first hit test against bounding box\n      if ((b && !b.contains(gx, gy)) || !b) continue;\n      // if in bounding box, perform more careful test\n      if (test(g, o, x, y, gx, gy)) return o;\n    }\n    return null;\n  };\n}\n\nfunction testPath(path, filled) {\n  return function(g, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = (filled == null) ? item.fill : filled,\n        stroke = item.stroke && g.isPointInStroke, lw, lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      g.lineWidth = lw != null ? lw : 1;\n      g.lineCap   = lc != null ? lc : 'butt';\n    }\n\n    return path(g, o) ? false :\n      (fill && g.isPointInPath(x, y)) ||\n      (stroke && g.isPointInStroke(x, y));\n  };\n}\n\nfunction pickPath(path) {\n  return pick(testPath(path));\n}\n\nfunction fill(g, o, opacity) {\n  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);\n  if (opacity > 0) {\n    g.globalAlpha = opacity;\n    g.fillStyle = color(g, o, o.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction stroke(g, o, opacity) {\n  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;\n  if (lw <= 0) return false;\n\n  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n  if (opacity > 0) {\n    g.globalAlpha = opacity;\n    g.strokeStyle = color(g, o, o.stroke);\n    g.lineWidth = lw;\n    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';\n    g.vgLineDash(o.strokeDash || null);\n    g.vgLineDashOffset(o.strokeDashOffset || 0);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction color(g, o, value) {\n  return (value.id) ?\n    gradient(g, value, o.bounds) :\n    value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\nmodule.exports = {\n  drawOne:  drawOne,\n  drawAll:  drawAll,\n  pick:     pick,\n  pickPath: pickPath,\n  testPath: testPath,\n  stroke:   stroke,\n  fill:     fill,\n  color:    color,\n  gradient: gradient\n};\n",
    "module.exports = {\n  'canvas': require('./canvas'),\n  'svg':    require('./svg')\n};\n",
    "var DOM = require('../../util/dom'),\n    Handler = require('../Handler');\n\nfunction SVGHandler() {\n  Handler.call(this);\n}\n\nvar base = Handler.prototype;\nvar prototype = (SVGHandler.prototype = Object.create(base));\nprototype.constructor = SVGHandler;\n\nprototype.initialize = function(el, pad, obj) {\n  this._svg = DOM.find(el, 'svg');\n  return base.initialize.call(this, el, pad, obj);\n};\n\nprototype.svg = function() {\n  return this._svg;\n};\n\n// wrap an event listener for the SVG DOM\nprototype.listener = function(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n    evt.vegaType = evt.type;\n    item = Array.isArray(item) ? item[0] : item;\n    handler.call(that._obj, evt, item);\n  };\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      svg = this._svg,\n      h = this._handlers,\n      x = {\n        type:     type,\n        handler:  handler,\n        listener: this.listener(handler)\n      };\n\n  (h[name] || (h[name] = [])).push(x);\n  svg.addEventListener(name, x.listener);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      svg = this._svg,\n      h = this._handlers[name], i;\n  if (!h) return;\n  for (i=h.length; --i>=0;) {\n    if (h[i].type === type && !handler || h[i].handler === handler) {\n      svg.removeEventListener(name, h[i].listener);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = SVGHandler;\n",
    "var ImageLoader = require('../../util/ImageLoader'),\n    Renderer = require('../Renderer'),\n    text = require('../../util/text'),\n    DOM = require('../../util/dom'),\n    SVG = require('../../util/svg'),\n    ns = SVG.metadata.xmlns,\n    marks = require('./marks');\n\nfunction SVGRenderer(loadConfig) {\n  Renderer.call(this);\n  this._loader = new ImageLoader(loadConfig);\n  this._dirtyID = 0;\n}\n\nvar base = Renderer.prototype;\nvar prototype = (SVGRenderer.prototype = Object.create(base));\nprototype.constructor = SVGRenderer;\n\nprototype.initialize = function(el, width, height, padding) {\n  if (el) {\n    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');\n    DOM.clear(el, 1);\n    // set the svg root group\n    this._root = DOM.child(this._svg, 0, 'g', ns);\n    DOM.clear(this._svg, 1);\n  }\n\n  // create the svg definitions cache\n  this._defs = {\n    clip_id:  1,\n    gradient: {},\n    clipping: {}\n  };\n\n  // set background color if defined\n  this.background(this._bgcolor);\n\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.background = function(bgcolor) {\n  if (arguments.length && this._svg) {\n    this._svg.style.setProperty('background-color', bgcolor);\n  }\n  return base.background.apply(this, arguments);\n};\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  \n  if (this._svg) {\n    var w = this._width,\n        h = this._height,\n        p = this._padding;\n  \n    this._svg.setAttribute('width', w + p.left + p.right);\n    this._svg.setAttribute('height', h + p.top + p.bottom);\n    \n    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');\n  }\n\n  return this;\n};\n\nprototype.svg = function() {\n  if (!this._svg) return null;\n\n  var attr = {\n    'class':  'marks',\n    'width':  this._width + this._padding.left + this._padding.right,\n    'height': this._height + this._padding.top + this._padding.bottom,\n  };\n  for (var key in SVG.metadata) {\n    attr[key] = SVG.metadata[key];\n  }\n\n  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');\n};\n\nprototype.imageURL = function(url) {\n  return this._loader.imageURL(url);\n};\n\n\n// -- Render entry point --\n\nprototype.render = function(scene, items) {\n  if (this._dirtyCheck(items)) {\n    if (this._dirtyAll) this._resetDefs();\n    this.draw(this._root, scene, -1);\n    DOM.clear(this._root, 1);\n  }\n  this.updateDefs();\n  return this;\n};\n\nprototype.draw = function(el, scene, index) {\n  this.drawMark(el, scene, index, marks[scene.marktype]);\n};\n\n\n// -- Manage SVG definitions ('defs') block --\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      defs = this._defs,\n      el = defs.el,\n      index = 0, id;\n\n  for (id in defs.gradient) {\n    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));\n    updateGradient(el, defs.gradient[id], index++);\n  }\n\n  for (id in defs.clipping) {\n    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));\n    updateClipping(el, defs.clipping[id], index++);\n  }\n\n  // clean-up\n  if (el) {\n    if (index === 0) {\n      svg.removeChild(el);\n      defs.el = null;\n    } else {\n      DOM.clear(el, index);      \n    }\n  }\n};\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  el = DOM.child(el, index, 'linearGradient', ns);\n  el.setAttribute('id', grad.id);\n  el.setAttribute('x1', grad.x1);\n  el.setAttribute('x2', grad.x2);\n  el.setAttribute('y1', grad.y1);\n  el.setAttribute('y2', grad.y2);\n  \n  for (i=0, n=grad.stops.length; i<n; ++i) {\n    stop = DOM.child(el, i, 'stop', ns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  DOM.clear(el, i);\n}\n\nfunction updateClipping(el, clip, index) {\n  var rect;\n\n  el = DOM.child(el, index, 'clipPath', ns);\n  el.setAttribute('id', clip.id);\n  rect = DOM.child(el, 0, 'rect', ns);\n  rect.setAttribute('x', 0);\n  rect.setAttribute('y', 0);\n  rect.setAttribute('width', clip.width);\n  rect.setAttribute('height', clip.height);\n}\n\nprototype._resetDefs = function() {\n  var def = this._defs;\n  def.clip_id = 1;\n  def.gradient = {};\n  def.clipping = {};\n};\n\n\n// -- Manage rendering of items marked as dirty --\n\nprototype.isDirty = function(item) {\n  return this._dirtyAll || item.dirty === this._dirtyID;\n};\n\nprototype._dirtyCheck = function(items) {\n  this._dirtyAll = true;\n  if (!items) return true;\n\n  var id = ++this._dirtyID,\n      item, mark, type, mdef, i, n, o;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    mark = item.mark;\n    if (mark.marktype !== type) {\n      // memoize mark instance lookup\n      type = mark.marktype;\n      mdef = marks[type];\n    }\n\n    if (item.status === 'exit') { // EXIT\n      if (item._svg) {\n        if (mdef.nest && item.mark.items.length) {\n          // if nested mark with remaining points, update instead\n          this._update(mdef, item._svg, item.mark.items[0]);\n          o = item.mark.items[0];\n          o._svg = item._svg;\n          o._update = id;\n        } else {\n          // otherwise remove from DOM\n          DOM.remove(item._svg);\n        }\n        item._svg = null;\n      }\n      continue;\n    }\n\n    item = (mdef.nest ? mark.items[0] : item);\n    if (item._update === id) { // Already processed\n      continue;\n    } else if (item._svg) { // UPDATE\n      this._update(mdef, item._svg, item);\n    } else { // ENTER\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n    }\n    item._update = id;\n  }\n  return !this._dirtyAll;\n};\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item=item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n\n// -- Construct & maintain scenegraph to SVG mapping ---\n\n// Draw a mark container.\nprototype.drawMark = function(el, scene, index, mdef) {\n  if (!this.isDirty(scene)) return;\n\n  var items = mdef.nest ?\n        (scene.items && scene.items.length ? [scene.items[0]] : []) :\n        scene.items || [],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = (mdef.tag === 'g'),\n      className = DOM.cssClass(scene),\n      p, i, n, c, d, insert;\n\n  p = DOM.child(el, index+1, 'g', ns, className);\n  p.setAttribute('class', className);\n  scene._svg = p;\n  if (!isGroup && events) {\n    p.style.setProperty('pointer-events', events);\n  }\n\n  for (i=0, n=items.length; i<n; ++i) {\n    if (this.isDirty(d = items[i])) {\n      insert = !(this._dirtyAll || d._svg);\n      c = bind(p, mdef, d, i, insert);\n      this._update(mdef, c, d);\n      if (isGroup) {\n        if (insert) this._dirtyAll = true;\n        this._recurse(c, d);\n        if (insert) this._dirtyAll = false;\n      }\n    }\n  }\n  DOM.clear(p, i);\n  return p;\n};\n\n// Recursively process group contents.\nprototype._recurse = function(el, group) {\n  var items = group.items || [],\n      legends = group.legendItems || [],\n      axes = group.axisItems || [],\n      idx = 0, j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer === 'back') {\n      this.drawMark(el, axes[j], idx++, marks.group);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    this.draw(el, items[j], idx++);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer !== 'back') {\n      this.drawMark(el, axes[j], idx++, marks.group);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    this.drawMark(el, legends[j], idx++, marks.group);\n  }\n\n  // remove any extraneous DOM elements\n  DOM.clear(el, 1 + idx);\n};\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(el, mdef, item, index, insert) {\n  // create svg element, bind item data for D3 compatibility\n  var node = DOM.child(el, index, mdef.tag, ns, null, insert);\n  node.__data__ = item;\n  node.__values__ = {fill: 'default'};\n\n  // create background rect\n  if (mdef.tag === 'g') {\n    var bg = DOM.child(node, 0, 'rect', ns, 'background');\n    bg.__data__ = item;\n  }\n\n  // add pointer from scenegraph item to svg element\n  return (item._svg = node);\n}\n\n\n// -- Set attributes & styles on SVG elements ---\n\nvar element = null, // temp var for current SVG element\n    values = null;  // temp var for current values hash\n\n// Extra configuration for certain mark types\nvar mark_extras = {\n  group: function(mdef, el, item) {\n    element = el.childNodes[0];\n    values = el.__values__; // use parent's values hash\n    mdef.background(emit, item, this);\n\n    var value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      element.style.setProperty('pointer-events', value);\n      values.events = value;\n    }\n  },\n  text: function(mdef, el, item) {\n    var str = text.value(item.text);\n    if (str !== values.text) {\n      el.textContent = str;\n      values.text = str;\n    }\n    str = text.font(item);\n    if (str !== values.font) {\n      el.style.setProperty('font', str);\n      values.font = str;\n    }\n  }\n};\n\nprototype._update = function(mdef, el, item) {\n  // set dom element and values cache\n  // provides access to emit method\n  element = el;\n  values = el.__values__;\n\n  // apply svg attributes\n  mdef.attr(emit, item, this);\n\n  // some marks need special treatment\n  var extra = mark_extras[mdef.type];\n  if (extra) extra(mdef, el, item);\n\n  // apply svg css styles\n  // note: element may be modified by 'extra' method\n  this.style(element, item);\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    if (ns) {\n      element.setAttributeNS(ns, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  } else {\n    // else remove DOM attribute\n    if (ns) {\n      element.removeAttributeNS(ns, name);\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\n\nprototype.style = function(el, o) {\n  if (o == null) return;\n  var i, n, prop, name, value;\n\n  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {\n    prop = SVG.styleProperties[i];\n    value = o[prop];\n    if (value === values[prop]) continue;\n\n    name = SVG.styles[prop];\n    if (value == null) {\n      if (name === 'fill') {\n        el.style.setProperty(name, 'none');\n      } else {\n        el.style.removeProperty(name);\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        this._defs.gradient[value.id] = value;\n        value = 'url(' + href() + '#' + value.id + ')';\n      }\n      el.style.setProperty(name, value+'');\n    }\n\n    values[prop] = value;\n  }\n};\n\nfunction href() {\n  return typeof window !== 'undefined' ? window.location.href : '';\n}\n\nmodule.exports = SVGRenderer;\n",
    "var Renderer = require('../Renderer'),\n    ImageLoader = require('../../util/ImageLoader'),\n    SVG = require('../../util/svg'),\n    text = require('../../util/text'),\n    DOM = require('../../util/dom'),\n    openTag = DOM.openTag,\n    closeTag = DOM.closeTag,\n    MARKS = require('./marks');\n\nfunction SVGStringRenderer(loadConfig) {\n  Renderer.call(this);\n\n  this._loader = new ImageLoader(loadConfig);\n\n  this._text = {\n    head: '',\n    root: '',\n    foot: '',\n    defs: '',\n    body: ''\n  };\n\n  this._defs = {\n    clip_id:  1,\n    gradient: {},\n    clipping: {}\n  };\n}\n\nvar base = Renderer.prototype;\nvar prototype = (SVGStringRenderer.prototype = Object.create(base));\nprototype.constructor = SVGStringRenderer;\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  var p = this._padding,\n      t = this._text;\n\n  var attr = {\n    'class':  'marks',\n    'width':  this._width + p.left + p.right,\n    'height': this._height + p.top + p.bottom,\n  };\n  for (var key in SVG.metadata) {\n    attr[key] = SVG.metadata[key];\n  }\n\n  t.head = openTag('svg', attr);\n  t.root = openTag('g', {\n    transform: 'translate(' + p.left + ',' + p.top + ')'\n  });\n  t.foot = closeTag('g') + closeTag('svg');\n\n  return this;\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.render = function(scene) {\n  this._text.body = this.mark(scene);\n  this._text.defs = this.buildDefs();\n  return this;\n};\n\nprototype.reset = function() {\n  this._defs.clip_id = 0;\n  return this;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      defs = '',\n      i, id, def, stops;\n\n  for (id in all.gradient) {\n    def = all.gradient[id];\n    stops = def.stops;\n\n    defs += openTag('linearGradient', {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (i=0; i<stops.length; ++i) {\n      defs += openTag('stop', {\n        offset: stops[i].offset,\n        'stop-color': stops[i].color\n      }) + closeTag('stop');\n    }\n    \n    defs += closeTag('linearGradient');\n  }\n  \n  for (id in all.clipping) {\n    def = all.clipping[id];\n\n    defs += openTag('clipPath', {id: id});\n\n    defs += openTag('rect', {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + closeTag('rect');\n\n    defs += closeTag('clipPath');\n  }\n  \n  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';\n};\n\nprototype.imageURL = function(url) {\n  return this._loader.imageURL(url);\n};\n\nvar object;\n\nfunction emit(name, value, ns, prefixed) {\n  object[prefixed || name] = value;\n}\n\nprototype.attributes = function(attr, item) {\n  object = {};\n  attr(emit, item, this);\n  return object;\n};\n\nprototype.mark = function(scene) {\n  var mdef = MARKS[scene.marktype],\n      tag  = mdef.tag,\n      attr = mdef.attr,\n      nest = mdef.nest || false,\n      data = nest ?\n          (scene.items && scene.items.length ? [scene.items[0]] : []) :\n          (scene.items || []),\n      defs = this._defs,\n      str = '',\n      style, i, item;\n\n  if (tag !== 'g' && scene.interactive === false) {\n    style = 'style=\"pointer-events: none;\"';\n  }\n\n  // render opening group tag\n  str += openTag('g', {\n    'class': DOM.cssClass(scene)\n  }, style);\n\n  // render contained elements\n  for (i=0; i<data.length; ++i) {\n    item = data[i];\n    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;\n    str += openTag(tag, this.attributes(attr, item), style);\n    if (tag === 'text') {\n      str += escape_text(text.value(item.text));\n    } else if (tag === 'g') {\n      str += openTag('rect',\n        this.attributes(mdef.background, item),\n        styles(item, scene, 'bgrect', defs)) + closeTag('rect');\n      str += this.markGroup(item);\n    }\n    str += closeTag(tag);\n  }\n\n  // render closing group tag\n  return str + closeTag('g');\n};\n\nprototype.markGroup = function(scene) {\n  var str = '',\n      axes = scene.axisItems || [],\n      items = scene.items || [],\n      legends = scene.legendItems || [],\n      j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer === 'back') {\n      str += this.mark(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    str += this.mark(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer !== 'back') {\n      str += this.mark(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    str += this.mark(legends[j]);\n  }\n\n  return str;\n};\n\nfunction styles(o, mark, tag, defs) {\n  if (o == null) return '';\n  var i, n, prop, name, value, s = '';\n\n  if (tag === 'bgrect' && mark.interactive === false) {\n    s += 'pointer-events: none;';\n  }\n\n  if (tag === 'text') {\n    s += 'font: ' + text.font(o) + ';';\n  }\n\n  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {\n    prop = SVG.styleProperties[i];\n    name = SVG.styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === 'fill') {\n        s += (s.length ? ' ' : '') + 'fill: none;';\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = 'url(#' + value.id + ')';\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';';\n    }\n  }\n\n  return s ? 'style=\"' + s + '\"' : null;\n}\n\nfunction escape_text(s) {\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nmodule.exports = SVGStringRenderer;\n",
    "module.exports = {\n  Handler:  require('./SVGHandler'),\n  Renderer: require('./SVGRenderer'),\n  string: {\n    Renderer : require('./SVGStringRenderer')\n  }\n};",
    "var text = require('../../util/text'),\n    SVG = require('../../util/svg'),\n    textAlign = SVG.textAlign,\n    path = SVG.path;\n\nfunction translateItem(o) {\n  return translate(o.x || 0, o.y || 0);\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\n\nmodule.exports = {\n  arc: {\n    tag:  'path',\n    type: 'arc',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', path.arc(o));\n    }\n  },\n  area: {\n    tag:  'path',\n    type: 'area',\n    nest: true,\n    attr: function(emit, o) {\n      var items = o.mark.items;\n      if (items.length) emit('d', path.area(items));\n    }\n  },\n  group: {\n    tag:  'g',\n    type: 'group',\n    attr: function(emit, o, renderer) {\n      var id = null, defs, c;\n      emit('transform', translateItem(o));\n      if (o.clip) {\n        defs = renderer._defs;\n        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);\n        c = defs.clipping[id] || (defs.clipping[id] = {id: id});\n        c.width = o.width || 0;\n        c.height = o.height || 0;\n      }\n      emit('clip-path', id ? ('url(#' + id + ')') : null);\n    },\n    background: function(emit, o) {\n      emit('class', 'background');\n      emit('width', o.width || 0);\n      emit('height', o.height || 0);\n    }\n  },\n  image: {\n    tag:  'image',\n    type: 'image',\n    attr: function(emit, o, renderer) {\n      var x = o.x || 0,\n          y = o.y || 0,\n          w = o.width || 0,\n          h = o.height || 0,\n          url = renderer.imageURL(o.url);\n\n      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);\n      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);\n\n      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');\n      emit('transform', translate(x, y));\n      emit('width', w);\n      emit('height', h);\n    }\n  },\n  line: {\n    tag:  'path',\n    type: 'line',\n    nest: true,\n    attr: function(emit, o) {\n      var items = o.mark.items;\n      if (items.length) emit('d', path.line(items));\n    }\n  },\n  path: {\n    tag:  'path',\n    type: 'path',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', o.path);\n    }\n  },\n  rect: {\n    tag:  'rect',\n    type: 'rect',\n    nest: false,\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('width', o.width || 0);\n      emit('height', o.height || 0);\n    }\n  },\n  rule: {\n    tag:  'line',\n    type: 'rule',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);\n      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);\n    }\n  },\n  symbol: {\n    tag:  'path',\n    type: 'symbol',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', path.symbol(o));\n    }\n  },\n  text: {\n    tag:  'text',\n    type: 'text',\n    nest: false,\n    attr: function(emit, o) {\n      var dx = (o.dx || 0),\n          dy = (o.dy || 0) + text.offset(o),\n          x = (o.x || 0),\n          y = (o.y || 0),\n          a = o.angle || 0,\n          r = o.radius || 0, t;\n\n      if (r) {\n        t = (o.theta || 0) - Math.PI/2;\n        x += r * Math.cos(t);\n        y += r * Math.sin(t);\n      }\n\n      emit('text-anchor', textAlign[o.align] || 'start');\n      \n      if (a) {\n        t = translate(x, y) + ' rotate('+a+')';\n        if (dx || dy) t += ' ' + translate(dx, dy);\n      } else {\n        t = translate(x+dx, y+dy);\n      }\n      emit('transform', t);\n    }\n  }\n};\n",
    "function Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nvar prototype = Bounds.prototype;\n\nprototype.clone = function() {\n  return new Bounds(this);\n};\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n};\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.alignsWith = function(b) {\n  return b && (\n    this.x1 == b.x1 ||\n    this.x2 == b.x2 ||\n    this.y1 == b.y1 ||\n    this.y2 == b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = Bounds;\n",
    "module.exports = function(b) {\n  function noop() { }\n  function add(x,y) { b.add(x, y); }\n\n  return {\n    bounds: function(_) {\n      if (!arguments.length) return b;\n      return (b = _, this);\n    },\n    beginPath: noop,\n    closePath: noop,\n    moveTo: add,\n    lineTo: add,\n    quadraticCurveTo: function(x1, y1, x2, y2) {\n      b.add(x1, y1);\n      b.add(x2, y2);\n    },\n    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {\n      b.add(x1, y1);\n      b.add(x2, y2);\n      b.add(x3, y3);\n    }\n  };\n};\n",
    "var gradient_id = 0;\n\nfunction Gradient(type) {\n  this.id = 'gradient_' + (gradient_id++);\n  this.type = type || 'linear';\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n}\n\nvar prototype = Gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = Gradient;",
    "var load = require('datalib/src/import/load');\n\nfunction ImageLoader(loadConfig) {\n  this._pending = 0;\n  this._config = loadConfig || ImageLoader.Config; \n}\n\n// Overridable global default load configuration\nImageLoader.Config = null;\n\nvar prototype = ImageLoader.prototype;\n\nprototype.pending = function() {\n  return this._pending;\n};\n\nprototype.params = function(uri) {\n  var p = {url: uri}, k;\n  for (k in this._config) { p[k] = this._config[k]; }\n  return p;\n};\n\nprototype.imageURL = function(uri) {\n  return load.sanitizeUrl(this.params(uri));\n};\n\nfunction browser(uri, callback) {\n  var url = load.sanitizeUrl(this.params(uri));\n  if (!url) { // error\n    if (callback) callback(uri, null);\n    return null;\n  }\n\n  var loader = this,\n      image = new Image();\n\n  loader._pending += 1;\n\n  image.onload = function() {\n    loader._pending -= 1;\n    image.loaded = true;\n    if (callback) callback(null, image);\n  };\n  image.src = url;\n\n  return image;\n}\n\nfunction server(uri, callback) {\n  var loader = this,\n      image = new ((typeof window !== \"undefined\" ? window['canvas'] : typeof global !== \"undefined\" ? global['canvas'] : null).Image)();\n\n  loader._pending += 1;\n\n  load(this.params(uri), function(err, data) {\n    loader._pending -= 1;\n    if (err) {\n      if (callback) callback(err, null);\n      return null;\n    }\n    image.src = data;\n    image.loaded = true;\n    if (callback) callback(null, image);\n  });\n\n  return image;\n}\n\nprototype.loadImage = function(uri, callback) {\n  return load.useXHR ?\n    browser.call(this, uri, callback) :\n    server.call(this, uri, callback);\n};\n\nmodule.exports = ImageLoader;\n",
    "function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) {\n    if (i===list.length-1) {\n      list.pop();\n    } else {\n      list.splice(i, 1);\n    }\n  }\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n};\n\nmodule.exports = Item;",
    "var BoundsContext = require('./BoundsContext'),\n    Bounds = require('./Bounds'),\n    canvas = require('./canvas'),\n    svg = require('./svg'),\n    text = require('./text'),\n    paths = require('../path'),\n    parse = paths.parse,\n    drawPath = paths.render,\n    areaPath = svg.path.area,\n    linePath = svg.path.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    g2D = null,\n    bc = BoundsContext();\n\nfunction context() {\n  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));\n}\n\nfunction strokeBounds(o, bounds) {\n  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {\n    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);\n  }\n  return bounds;\n}\n\nfunction pathBounds(o, path, bounds, x, y) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    drawPath(bc.bounds(bounds), path, x, y);\n    strokeBounds(o, bounds);\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;\n  return pathBounds(o, p, bounds, o.x, o.y);\n}\n\nfunction area(mark, bounds) {\n  if (mark.items.length === 0) return bounds;\n  var items = mark.items,\n      item = items[0],\n      p = item.pathCache || (item.pathCache = parse(areaPath(items)));\n  return pathBounds(item, p, bounds);\n}\n\nfunction line(mark, bounds) {\n  if (mark.items.length === 0) return bounds;\n  var items = mark.items,\n      item = items[0],\n      p = item.pathCache || (item.pathCache = parse(linePath(items)));\n  return pathBounds(item, p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x, y;\n  return strokeBounds(o, bounds.set(\n    x = o.x || 0,\n    y = o.y || 0,\n    (x + o.width) || 0,\n    (y + o.height) || 0\n  ));\n}\n\nfunction image(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = o.width || 0,\n      h = o.height || 0;\n  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));\n  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  return strokeBounds(o, bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  ));\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa % halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  return strokeBounds(o, bounds.set(\n    cx + xmin,\n    cy + ymin,\n    cx + xmax,\n    cy + ymax\n  ));\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case 'cross':\n      t = 3 * Math.sqrt(size / 5) / 2;\n      bounds.set(x-t, y-t, x+t, y+t);\n      break;\n\n    case 'diamond':\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case 'square':\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case 'triangle-down':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case 'triangle-up':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n\n  return strokeBounds(o, bounds);\n}\n\nfunction textMark(o, bounds, noRotate) {\n  var g = context(),\n      h = text.size(o),\n      a = o.align,\n      r = o.radius || 0,\n      x = (o.x || 0),\n      y = (o.y || 0),\n      dx = (o.dx || 0),\n      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset\n      w, t;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal alignment\n  g.font = text.font(o);\n  w = g.measureText(text.value(o.text)).width;\n  if (a === 'center') {\n    dx -= (w / 2);\n  } else if (a === 'right') {\n    dx -= w;\n  } else {\n    // left by default, do nothing\n  }\n\n  bounds.set(dx+=x, dy+=y, dx+w, dy+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, x, y);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      items = g.items || [],\n      legends = g.legendItems || [],\n      j, m;\n\n  if (!g.clip) {\n    for (j=0, m=axes.length; j<m; ++j) {\n      bounds.union(axes[j].bounds);\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n    if (includeLegends) {\n      for (j=0, m=legends.length; j<m; ++j) {\n        bounds.union(legends[j].bounds);\n      }\n    }\n  }\n  if (g.clip || g.width || g.height) {\n    strokeBounds(g, bounds\n      .add(0, 0)\n      .add(g.width || 0, g.height || 0));\n  }\n  return bounds.translate(g.x || 0, g.y || 0);\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   textMark,\n  path:   path,\n  area:   area,\n  line:   line\n};\nmethods.area.nest = true;\nmethods.line.nest = true;\n\nfunction itemBounds(item, func, opt) {\n  var type = item.mark.marktype;\n  func = func || methods[type];\n  if (func.nest) item = item.mark;\n\n  var curr = item.bounds,\n      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());\n\n  if (curr) {\n    prev.clear().union(curr);\n    curr.clear();\n  } else {\n    item.bounds = new Bounds();\n  }\n  func(item, item.bounds, opt);\n  if (!curr) prev.clear().union(item.bounds);\n  return item.bounds;\n}\n\nvar DUMMY_ITEM = {mark: null};\n\nfunction markBounds(mark, bounds, opt) {\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      hasi  = items && items.length,\n      i, n, o, b;\n\n  if (func.nest) {\n    o = hasi ? items[0]\n      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it\n    b = itemBounds(o, func, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  if (hasi) {  \n    for (i=0, n=items.length; i<n; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  return (mark.bounds = bounds);\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  textMark,\n  group: group\n};\n",
    "function instance(w, h) {\n  w = w || 1;\n  h = h || 1;\n  var canvas;\n\n  if (typeof document !== 'undefined' && document.createElement) {\n    canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n  } else {\n    var Canvas = (typeof window !== \"undefined\" ? window['canvas'] : typeof global !== \"undefined\" ? global['canvas'] : null);\n    if (!Canvas.prototype) return null;\n    canvas = new Canvas(w, h);\n  }\n  return lineDash(canvas);\n}\n\nfunction resize(canvas, w, h, p, retina) {\n  var g = this._ctx = canvas.getContext('2d'), \n      s = 1;\n\n  canvas.width = w + p.left + p.right;\n  canvas.height = h + p.top + p.bottom;\n\n  // if browser canvas, attempt to modify for retina display\n  if (retina && typeof HTMLElement !== 'undefined' &&\n      canvas instanceof HTMLElement)\n  {\n    g.pixelratio = (s = pixelRatio(canvas) || 1);\n  }\n\n  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);\n  return canvas;\n}\n\nfunction pixelRatio(canvas) {\n  var g = canvas.getContext('2d');\n\n  // get canvas pixel data\n  var devicePixelRatio = window && window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        g.webkitBackingStorePixelRatio ||\n        g.mozBackingStorePixelRatio ||\n        g.msBackingStorePixelRatio ||\n        g.oBackingStorePixelRatio ||\n        g.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    // set actual and visible canvas size\n    var w = canvas.width,\n        h = canvas.height;\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n\n  return ratio;\n}\n\nfunction lineDash(canvas) {\n  var g = canvas.getContext('2d');\n  if (g.vgLineDash) return; // already initialized!\n\n  var NOOP = function() {},\n      NODASH = [];\n  \n  if (g.setLineDash) {\n    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (g.webkitLineDash !== undefined) {\n  \tg.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (g.mozDash !== undefined) {\n    g.vgLineDash = function(dash) { this.mozDash = dash; };\n    g.vgLineDashOffset = NOOP;\n  } else {\n    g.vgLineDash = NOOP;\n    g.vgLineDashOffset = NOOP;\n  }\n  return canvas;\n}\n\nmodule.exports = {\n  instance:   instance,\n  resize:     resize,\n  lineDash:   lineDash\n};\n",
    "// create a new DOM element\nfunction create(doc, tag, ns) {\n  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);\n}\n\n// remove element from DOM\n// recursively remove parent elements if empty\nfunction remove(el) {\n  if (!el) return;\n  var p = el.parentNode;\n  if (p) {\n    p.removeChild(el);\n    if (!p.childNodes || !p.childNodes.length) remove(p);\n  }\n}\n\nmodule.exports = {\n  // find first child element with matching tag\n  find: function(el, tag) {\n    tag = tag.toLowerCase();\n    for (var i=0, n=el.childNodes.length; i<n; ++i) {\n      if (el.childNodes[i].tagName.toLowerCase() === tag) {\n        return el.childNodes[i];\n      }\n    }\n  },\n  // retrieve child element at given index\n  // create & insert if doesn't exist or if tag/className do not match\n  child: function(el, index, tag, ns, className, insert) {\n    var a, b;\n    a = b = el.childNodes[index];\n    if (!a || insert ||\n        a.tagName.toLowerCase() !== tag.toLowerCase() ||\n        className && a.getAttribute('class') != className) {\n      a = create(el.ownerDocument, tag, ns);\n      el.insertBefore(a, b);\n      if (className) a.setAttribute('class', className);\n    }\n    return a;\n  },\n  // remove all child elements at or above the given index\n  clear: function(el, index) {\n    var curr = el.childNodes.length;\n    while (curr > index) {\n      el.removeChild(el.childNodes[--curr]);\n    }\n    return el;\n  },\n  remove: remove,\n  // generate css class name for mark\n  cssClass: function(mark) {\n    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');\n  },\n  // generate string for an opening xml tag\n  // tag: the name of the xml tag\n  // attr: hash of attribute name-value pairs to include\n  // raw: additional raw string to include in tag markup\n  openTag: function(tag, attr, raw) {\n    var s = '<' + tag, key, val;\n    if (attr) {\n      for (key in attr) {\n        val = attr[key];\n        if (val != null) {\n          s += ' ' + key + '=\"' + val + '\"';\n        }\n      }\n    }\n    if (raw) s += ' ' + raw;\n    return s + '>';\n  },\n  // generate string for closing xml tag\n  // tag: the name of the xml tag\n  closeTag: function(tag) {\n    return '</' + tag + '>';\n  }\n};\n",
    "var bound = require('../util/bound');\n\nvar sets = [\n  'items',\n  'axisItems',\n  'legendItems'\n];\n\nvar keys = [\n  'marktype', 'name', 'interactive', 'clip',\n  'items', 'axisItems', 'legendItems', 'layer',\n  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\n  'fill', 'fillOpacity', 'opacity',                             // fill\n  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\n  'strokeDash', 'strokeDashOffset',                             // stroke dash\n  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\n  'interpolate', 'tension', 'orient',                           // area, line\n  'url',                                                        // image\n  'path',                                                       // path\n  'x2', 'y2',                                                   // rule\n  'size', 'shape',                                              // symbol\n  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text\n  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font\n];\n\nfunction toJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nfunction fromJSON(json) {\n  var scene = (typeof json === 'string' ? JSON.parse(json) : json);\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      i, n, s, m, items;\n\n  for (s=0, m=sets.length; s<m; ++s) {\n    if ((items = scene[sets[s]])) {\n      for (i=0, n=items.length; i<n; ++i) {\n        items[i][type ? 'mark' : 'group'] = scene;\n        if (!type || type === 'group') {\n          initialize(items[i]);\n        }\n      }\n    }\n  }\n\n  if (type) bound.mark(scene);\n  return scene;\n}\n\nmodule.exports = {\n  toJSON:   toJSON,\n  fromJSON: fromJSON\n};",
    "var d3_svg = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null).svg;\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return (o.x || 0) + (o.width || 0); }\nfunction yh(o)    { return (o.y || 0) + (o.height || 0); }\nfunction size(o)  { return o.size == null ? 100 : o.size; }\nfunction shape(o) { return o.shape || 'circle'; }\n\nvar areav = d3_svg.area().x(x).y1(y).y0(yh),\n    areah = d3_svg.area().y(y).x1(x).x0(xw),\n    line  = d3_svg.line().x(x).y(y);\n\nmodule.exports = {\n  metadata: {\n    'version': '1.1',\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink'\n  },\n  path: {\n    arc: d3_svg.arc(),\n    symbol: d3_svg.symbol().type(shape).size(size),\n    area: function(items) {\n      var o = items[0];\n      return (o.orient === 'horizontal' ? areah : areav)\n        .interpolate(o.interpolate || 'linear')\n        .tension(o.tension || 0.7)\n        (items);\n    },\n    line: function(items) {\n      var o = items[0];\n      return line\n        .interpolate(o.interpolate || 'linear')\n        .tension(o.tension || 0.7)\n        (items);\n    }\n  },\n  textAlign: {\n    'left':   'start',\n    'center': 'middle',\n    'right':  'end'\n  },\n  textBaseline: {\n    'top':    'before-edge',\n    'bottom': 'after-edge',\n    'middle': 'central'\n  },\n  styles: {\n    'fill':             'fill',\n    'fillOpacity':      'fill-opacity',\n    'stroke':           'stroke',\n    'strokeWidth':      'stroke-width',\n    'strokeOpacity':    'stroke-opacity',\n    'strokeCap':        'stroke-linecap',\n    'strokeDash':       'stroke-dasharray',\n    'strokeDashOffset': 'stroke-dashoffset',\n    'opacity':          'opacity'\n  },\n  styleProperties: [\n    'fill',\n    'fillOpacity',\n    'stroke',\n    'strokeWidth',\n    'strokeOpacity',\n    'strokeCap',\n    'strokeDash',\n    'strokeDashOffset',\n    'opacity'\n  ]\n};\n",
    "function size(item) {\n  return item.fontSize != null ? item.fontSize : 11;\n}\n\nmodule.exports = {\n  size: size,\n  value: function(s) {\n    return s != null ? String(s) : '';\n  },\n  font: function(item, quote) {\n    var font = item.font;\n    if (quote && font) {\n      font = String(font).replace(/\\\"/g, '\\'');\n    }\n    return '' +\n      (item.fontStyle ? item.fontStyle + ' ' : '') +\n      (item.fontVariant ? item.fontVariant + ' ' : '') +\n      (item.fontWeight ? item.fontWeight + ' ' : '') +\n      size(item) + 'px ' +\n      (font || 'sans-serif');\n  },\n  offset: function(item) {\n    // perform our own font baseline calculation\n    // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n    var baseline = item.baseline,\n        h = size(item);\n    return Math.round(\n      baseline === 'top'    ?  0.93*h :\n      baseline === 'middle' ?  0.30*h :\n      baseline === 'bottom' ? -0.21*h : 0\n    );\n  }\n};\n",
    "var sg = require('vega-scenegraph').render,\n    canvas = sg.canvas,\n    svg = sg.svg.string,\n    View = require('./View');\n\nfunction HeadlessView(width, height, model) {\n  View.call(this, width, height, model);\n  this._type = 'canvas';\n  this._renderers = {canvas: canvas, svg: svg};\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return (this._type === 'canvas') ? this._renderer.canvas() : null;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n\n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view.canvas());\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  if (this._type !== 'canvas') return null;\n  if (r.pendingImages() > 0) { wait(); } else { callback(this.canvas()); }\n};\n\nprototype.svg = function() {\n  return (this._type === 'svg') ? this._renderer.svg() : null;\n};\n\nprototype.initialize = function() {\n  var w = this._width,\n      h = this._height,\n      bg  = this._bgcolor,\n      pad = this._padding,\n      config = this.model().config();\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = (this._renderer || new this._io.Renderer(config.load))\n    .initialize(null, w, h, pad)\n    .background(bg);\n\n  return this;\n};\n\nmodule.exports = HeadlessView;",
    "var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    ChangeSet = df.ChangeSet,\n    Base = df.Graph.prototype,\n    Node  = df.Node, // jshint ignore:line\n    GroupBuilder = require('../scene/GroupBuilder'),\n    visit = require('../scene/visit'),\n    config = require('./config');\n\nfunction Model(cfg) {\n  this._defs = {};\n  this._predicates = {};\n\n  this._scene  = null;  // Root scenegraph node.\n  this._groups = null;  // Index of group items.\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder.\n\n  this._reset = {axes: false, legends: false};\n\n  this.config(cfg);\n  Base.init.call(this);\n}\n\nvar prototype = (Model.prototype = Object.create(Base));\nprototype.constructor = Model;\n\nprototype.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nprototype.config = function(cfg) {\n  if (!arguments.length) return this._config;\n  this._config = Object.create(config);\n  for (var name in cfg) {\n    var x = cfg[name], y = this._config[name];\n    if (dl.isObject(x) && dl.isObject(y)) {\n      dl.extend(y, x);\n    } else {\n      this._config[name] = x;\n    }\n  }\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (this._defs) this._defs.width = width;\n  if (this._defs && this._defs.marks) this._defs.marks.width = width;\n  if (this._scene) {\n    this._scene.items[0].width = width;\n    this._scene.items[0]._dirty = true;\n  }\n  this._reset.axes = true;\n  return this;\n};\n\nprototype.height = function(height) {\n  if (this._defs) this._defs.height = height;\n  if (this._defs && this._defs.marks) this._defs.marks.height = height;\n  if (this._scene) {\n    this._scene.items[0].height = height;\n    this._scene.items[0]._dirty = true;\n  }\n  this._reset.axes = true;\n  return this;\n};\n\nprototype.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nprototype.data = function() {\n  var data = Base.data.apply(this, arguments);\n  if (arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, pred = {};\n  if (!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { pred[n] = m._predicates[n]; });\n  return pred;\n}\n\nprototype.predicate = function(name, predicate) {\n  if (arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nprototype.predicates = function() { return this._predicates; };\n\nprototype.scene = function(renderer) {\n  if (!arguments.length) return this._scene;\n\n  if (this._builder) {\n    this.node().removeListener(this._builder);\n    this._builder._groupBuilder.disconnect();\n  }\n\n  var m = this,\n      b = this._builder = new Node(this);\n\n  b.evaluate = function(input) {\n    if (b._groupBuilder) return input;\n\n    var gb = b._groupBuilder = new GroupBuilder(m, m._defs.marks, m._scene={}),\n        p  = gb.pipeline();\n\n    m._groups = {};\n    this.addListener(gb.connect());\n    p[p.length-1].addListener(renderer);\n    return input;\n  };\n\n  this.addListener(b);\n  return this;\n};\n\nprototype.group = function(id, item) {\n  var groups = this._groups;\n  if (arguments.length === 1) return groups[id];\n  return (groups[id] = item, this);\n};\n\nprototype.reset = function() {\n  if (this._scene && this._reset.axes) {\n    visit(this._scene, function(item) {\n      if (item.axes) item.axes.forEach(function(axis) { axis.reset(); });\n    });\n    this._reset.axes = false;\n  }\n  if (this._scene && this._reset.legends) {\n    visit(this._scene, function(item) {\n      if (item.legends) item.legends.forEach(function(l) { l.reset(); });\n    });\n    this._reset.legends = false;\n  }\n  return this;\n};\n\nprototype.addListener = function(l) {\n  this.node().addListener(l);\n};\n\nprototype.removeListener = function(l) {\n  this.node().removeListener(l);\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    sg = require('vega-scenegraph').render,\n    log = require('vega-logging'),\n    Deps = df.Dependencies,\n    parseStreams = require('../parse/streams'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition');\n\nfunction View(el, width, height) {\n  this._el    = null;\n  this._model = null;\n  this._width   = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._bgcolor = null;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._repaint = true; // Full re-render on every re-init\n  this._renderers = sg;\n  this._io  = null;\n  this._api = {}; // Stash streaming data API sandboxes.\n}\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new df.Node(model);\n    this._streamer._rank = -1;  // HACK: To reduce re-ranking churn.\n    this._changeset = df.ChangeSet.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      name = ds.name(),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      api = {};\n\n  // If we have it stashed, don't create a new closure.\n  if (this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    view._changeset.data[name] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    view._changeset.data[name] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    view._changeset.data[name] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values(); };\n\n  return (this._api[src] = api);\n}\n\nprototype.data = function(data) {\n  var v = this;\n  if (!arguments.length) return v._model.values();\n  else if (dl.isString(data)) return streaming.call(v, data);\n  else if (dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nvar VIEW_SIGNALS = dl.toMap(['width', 'height', 'padding']);\n\nprototype.signal = function(name, value, propagate) {\n  var m = this._model,\n      key, values;\n\n  // Getter. Returns the value for the specified signal, or\n  // returns all signal values.\n  if (!arguments.length) {\n    return m.values(Deps.SIGNALS);\n  } else if (arguments.length === 1 && dl.isString(name)) {\n    return m.values(Deps.SIGNALS, name);\n  }\n\n  // Setter. Can be done in batch or individually. In either case,\n  // the final argument determines if set values should propagate.\n  if (dl.isObject(name)) {\n    values = name;\n    propagate = value;\n  } else {\n    values = {};\n    values[name] = value;\n  }\n  for (key in values) {\n    if (VIEW_SIGNALS[key]) {\n      this[key](values[key]);\n    } else {\n      setSignal.call(this, key, values[key], propagate);\n    }\n  }\n  return this;\n};\n\nfunction setSignal(name, value, propagate) {\n  var cs = this._changeset;\n  this._streamer.addListener(this._model.signal(name).value(value));\n  if (propagate !== false) cs.signals[name] = 1;\n  cs.reflow = true;\n}\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.model().width(width);\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n    setSignal.call(this, 'width', width);\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.model().height(height);\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n    setSignal.call(this, 'height', height);\n  }\n  return this;\n};\n\nprototype.background = function(bgcolor) {\n  if (!arguments.length) return this._bgcolor;\n  if (this._bgcolor !== bgcolor) {\n    this._bgcolor = bgcolor;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === 'strict');\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._renderer) this._renderer.resize(this._width, this._height, this._padding);\n    if (this._handler)  this._handler.padding(this._padding);\n    setSignal.call(this, 'padding', this._padding);\n  }\n  return (this._repaint = true, this);\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var b = this.model().scene().bounds,\n      pad = this._padding,\n      config = this.model().config(),\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0;\n  b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n\n    this._model.width(this._width).height(this._height).reset();\n    setSignal.call(this, 'width', this._width);\n    setSignal.call(this, 'height', this._height);\n    setSignal.call(this, 'padding', pad);\n\n    this.initialize().update({props:'enter'}).update({props:'update'});\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error('Unknown renderer: ' + type);\n  else if (!type) throw new Error('No renderer specified');\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding, bg = v._bgcolor,\n      config = this.model().config();\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if (!el) return this;  // This View cannot init w/o an\n  }\n\n  // clear pre-existing container\n  d3.select(el).select('div.vega').remove();\n\n  // add div container\n  this._el = el = d3.select(el)\n    .append('div')\n    .attr('class', 'vega')\n    .style('position', 'relative')\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style('width',  (v._viewport[0] || w)+'px')\n      .style('height', (v._viewport[1] || h)+'px')\n      .style('overflow', 'auto');\n  }\n\n  // renderer\n  sg.canvas.Renderer.RETINA = config.render.retina;\n  v._renderer = (v._renderer || new this._io.Renderer(config.load))\n    .initialize(el, w, h, pad)\n    .background(bg);\n\n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    v._detach = parseStreams(this);\n  }\n\n  return (this._repaint = true, this);\n};\n\nprototype.destroy = function() {\n  if (this._detach) this._detach();\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new df.Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    log.debug(input, ['rendering']);\n\n    var s = v._model.scene(),\n        h = v._handler;\n\n    if (h && h.scene) h.scene(s);\n\n    if (input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else if (v._repaint) {\n      v._renderer.render(s);\n      v._repaint = false;\n    } else if (input.dirty.length) {\n      v._renderer.render(s, input.dirty);\n    }\n\n    if (input.dirty.length) {\n      input.dirty.forEach(function(i) { i._dirty = false; });\n      s.items[0]._dirty = false;\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);\n}\n\nprototype.update = function(opt) {\n  opt = opt || {};\n  var v = this,\n      model = this._model,\n      streamer = this._streamer,\n      cs = this._changeset,\n      trans = opt.duration ? new Transition(opt.duration, opt.ease) : null;\n\n  if (trans) cs.trans = trans;\n  if (opt.props !== undefined) {\n    if (dl.keys(cs.data).length > 0) {\n      throw Error(\n        'New data values are not reflected in the visualization.' +\n        ' Please call view.update() before updating a specified property set.'\n      );\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  var built = v._build;\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, re-evaluate the entire model (datasources + scene).\n  if (opt.items && built) {\n    Encoder.update(model, opt.trans, opt.props, opt.items, cs.dirty);\n    v._renderNode.evaluate(cs);\n  } else if (streamer.listeners().length && built) {\n    // Include re-evaluation entire model when repaint flag is set\n    if (this._repaint) streamer.addListener(model.node());\n    model.propagate(cs, streamer);\n    streamer.disconnect();\n  } else {\n    model.fire(cs);\n  }\n\n  v._changeset = df.ChangeSet.create();\n\n  return v.autopad(opt);\n};\n\nprototype.toImageURL = function(type) {\n  var v = this, Renderer;\n\n  // lookup appropriate renderer\n  switch (type || 'png') {\n    case 'canvas':\n    case 'png':\n      Renderer = sg.canvas.Renderer; break;\n    case 'svg':\n      Renderer = sg.svg.string.Renderer; break;\n    default: throw Error('Unrecognized renderer type: ' + type);\n  }\n\n  var retina = sg.canvas.Renderer.RETINA;\n  sg.canvas.Renderer.RETINA = false; // ignore retina screen\n\n  // render the scenegraph\n  var ren = new Renderer(v._model.config.load)\n    .initialize(null, v._width, v._height, v._padding)\n    .render(v._model.scene());\n\n  sg.canvas.Renderer.RETINA = retina; // restore retina settings\n\n  // return data url\n  if (type === 'svg') {\n    var blob = new Blob([ren.svg()], {type: 'image/svg+xml'});\n    return window.URL.createObjectURL(blob);\n  } else {\n    return ren.canvas().toDataURL('image/png');\n  }\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || 'canvas')\n      .width(defs.width)\n      .height(defs.height)\n      .background(defs.background)\n      .padding(defs.padding)\n      .viewport(defs.viewport)\n      .initialize(opt.el);\n\n    if (opt.data) v.data(opt.data);\n\n    if (opt.hover !== false && opt.el) {\n      v.on('mouseover', function(evt, item) {\n        if (item && item.hasPropertySet('hover')) {\n          this.update({props:'hover', items:item});\n        }\n      })\n      .on('mouseout', function(evt, item) {\n        if (item && item.hasPropertySet('hover')) {\n          this.update({props:'update', items:item});\n        }\n      });\n    }\n\n    return v;\n  };\n};\n\nmodule.exports = View;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    config = {};\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: '',\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  retina: true\n};\n\n// root scenegraph group\nconfig.scene = {\n  fill: undefined,\n  fillOpacity: undefined,\n  stroke: undefined,\n  strokeOpacity: undefined,\n  strokeWidth: undefined,\n  strokeDash: undefined,\n  strokeDashOffset: undefined\n};\n\n// default axis properties\nconfig.axis = {\n  orient: 'bottom',\n  ticks: 10,\n  padding: 3,\n  axisColor: '#000',\n  axisWidth: 1,\n  gridColor: '#000',\n  gridOpacity: 0.15,\n  tickColor: '#000',\n  tickLabelColor: '#000',\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: 'sans-serif',\n  titleColor: '#000',\n  titleFont: 'sans-serif',\n  titleFontSize: 11,\n  titleFontWeight: 'bold',\n  titleOffset: 'auto',\n  titleOffsetAutoMin: 30,\n  titleOffsetAutoMax: Infinity,\n  titleOffsetAutoMargin: 4\n};\n\n// default legend properties\nconfig.legend = {\n  orient: 'right',\n  offset: 20,\n  padding: 3, // padding between legend items and border\n  margin: 2,  // extra margin between two consecutive legends\n  gradientStrokeColor: '#888',\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: '#000',\n  labelFontSize: 10,\n  labelFont: 'sans-serif',\n  labelAlign: 'left',\n  labelBaseline: 'middle',\n  labelOffset: 8,\n  symbolShape: 'circle',\n  symbolSize: 50,\n  symbolColor: '#888',\n  symbolStrokeWidth: 1,\n  titleColor: '#000',\n  titleFont: 'sans-serif',\n  titleFontSize: 11,\n  titleFontWeight: 'bold'\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10:  d3.scale.category10().range(),\n  category20:  d3.scale.category20().range(),\n  category20b: d3.scale.category20b().range(),\n  category20c: d3.scale.category20c().range(),\n  shapes: [\n    'circle',\n    'cross',\n    'diamond',\n    'square',\n    'triangle-down',\n    'triangle-up'\n  ]\n};\n\nmodule.exports = config;",
    "var dl = require('datalib'),\n    parse = require('../parse'),\n    Scale = require('../scene/Scale'),\n    config = require('./config');\n\nfunction compile(module, opt, schema) {\n  var s = module.schema;\n  if (!s) return;\n  if (s.refs) dl.extend(schema.refs, s.refs);\n  if (s.defs) dl.extend(schema.defs, s.defs);\n}\n\nmodule.exports = function(opt) {\n  var schema = null;\n  opt = opt || {};\n\n  // Compile if we're not loading the schema from a URL.\n  // Load from a URL to extend the existing base schema.\n  if (opt.url) {\n    schema = dl.json(dl.extend({url: opt.url}, config.load));\n  } else {\n    schema = {\n      \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n      \"title\": \"Vega Visualization Specification Language\",\n      \"defs\": {},\n      \"refs\": {},\n      \"$ref\": \"#/defs/spec\"\n    };\n\n    dl.keys(parse).forEach(function(k) { compile(parse[k], opt, schema); });\n\n    // Scales aren't in the parser, add schema manually\n    compile(Scale, opt, schema);\n  }\n\n  // Extend schema to support custom mark properties or property sets.\n  if (opt.properties) dl.keys(opt.properties).forEach(function(k) {\n    schema.defs.propset.properties[k] = {\"$ref\": \"#/refs/\"+opt.properties[k]+\"Value\"};\n  });\n\n  if (opt.propertySets) dl.keys(opt.propertySets).forEach(function(k) {\n    schema.defs.mark.properties.properties.properties[k] = {\"$ref\": \"#/defs/propset\"};\n  });\n\n  return schema;\n};",
    "var dl = require('datalib'),\n    axs = require('../scene/axis');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction parseAxes(model, spec, axes, group) {\n  var config = model.config();\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    parseAxis(config, def, index, axes[index], group);\n  });\n}\n\nfunction parseAxis(config, def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null ?\n    def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  axis.tickFormatType(def.formatType || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // axis tick count\n  axis.tickCount(def.ticks || config.axis.ticks);\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks ?\n      dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks ?\n      dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = parseAxes;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null);\n\nfunction parseBg(bg) {\n  // return null if input is null or undefined\n  if (bg == null) return null;\n  // run through d3 rgb to sanity check\n  return d3.rgb(bg) + '';\n}\n\nmodule.exports = parseBg;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nfunction parseData(model, spec, callback) {\n  var config = model.config(),\n      count = 0;\n\n  function onError(error, d) {\n    log.error('PARSE DATA FAILED: ' + d.name + ' ' + error);\n    count = -1;\n    callback(error);\n  }\n\n  function onLoad(d) {\n    return function(error, data) {\n      if (error) {\n        onError(error, d);\n      } else if (count > 0) {\n        try {\n          model.data(d.name).values(dl.read(data, d.format));\n          if (--count === 0) callback();\n        } catch (err) {\n          onError(err, d);\n        }\n      }\n    };\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), onLoad(d));\n    }\n    try {\n      parseData.datasource(model, d);\n    } catch (err) {\n      onError(err, d);\n    }\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n}\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform || []).map(function(t) {\n        return parseTransforms(model, t);\n      }),\n      mod = (d.modify || []).map(function(m) {\n        return parseModify(model, m, d);\n      }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    // Derived ds will be pulsed by its src rather than the model.\n    ds.source(d.source).addListener(ds);\n    model.removeListener(ds.pipeline()[0]);\n  }\n\n  return ds;\n};\n\nmodule.exports = parseData;",
    "module.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = \",\",\n        peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c3 = function(o, m) { return [o].concat(m); },\n        peg$c4 = function(o) { return [o]; },\n        peg$c5 = \"[\",\n        peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c7 = \"]\",\n        peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c9 = \">\",\n        peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}; },\n        peg$c12 = [],\n        peg$c13 = function(s, f) { return (s.filters = f, s); },\n        peg$c14 = function(s) { return s; },\n        peg$c15 = \"(\",\n        peg$c16 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c17 = \")\",\n        peg$c18 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c19 = function(m) { return {stream: m}; },\n        peg$c20 = \"@\",\n        peg$c21 = { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n        peg$c22 = \":\",\n        peg$c23 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c24 = function(n, e) { return {event: e, name: n}; },\n        peg$c25 = function(m, e) { return {event: e, mark: m}; },\n        peg$c26 = function(t, e) { return {event: e, target: t}; },\n        peg$c27 = function(e) { return {event: e}; },\n        peg$c28 = function(s) { return {signal: s}; },\n        peg$c29 = \"rect\",\n        peg$c30 = { type: \"literal\", value: \"rect\", description: \"\\\"rect\\\"\" },\n        peg$c31 = \"symbol\",\n        peg$c32 = { type: \"literal\", value: \"symbol\", description: \"\\\"symbol\\\"\" },\n        peg$c33 = \"path\",\n        peg$c34 = { type: \"literal\", value: \"path\", description: \"\\\"path\\\"\" },\n        peg$c35 = \"arc\",\n        peg$c36 = { type: \"literal\", value: \"arc\", description: \"\\\"arc\\\"\" },\n        peg$c37 = \"area\",\n        peg$c38 = { type: \"literal\", value: \"area\", description: \"\\\"area\\\"\" },\n        peg$c39 = \"line\",\n        peg$c40 = { type: \"literal\", value: \"line\", description: \"\\\"line\\\"\" },\n        peg$c41 = \"rule\",\n        peg$c42 = { type: \"literal\", value: \"rule\", description: \"\\\"rule\\\"\" },\n        peg$c43 = \"image\",\n        peg$c44 = { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n        peg$c45 = \"text\",\n        peg$c46 = { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n        peg$c47 = \"group\",\n        peg$c48 = { type: \"literal\", value: \"group\", description: \"\\\"group\\\"\" },\n        peg$c49 = \"mousedown\",\n        peg$c50 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n        peg$c51 = \"mouseup\",\n        peg$c52 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n        peg$c53 = \"click\",\n        peg$c54 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n        peg$c55 = \"dblclick\",\n        peg$c56 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n        peg$c57 = \"wheel\",\n        peg$c58 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n        peg$c59 = \"keydown\",\n        peg$c60 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n        peg$c61 = \"keypress\",\n        peg$c62 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n        peg$c63 = \"keyup\",\n        peg$c64 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n        peg$c65 = \"mousewheel\",\n        peg$c66 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n        peg$c67 = \"mousemove\",\n        peg$c68 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n        peg$c69 = \"mouseout\",\n        peg$c70 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n        peg$c71 = \"mouseover\",\n        peg$c72 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n        peg$c73 = \"mouseenter\",\n        peg$c74 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n        peg$c75 = \"touchstart\",\n        peg$c76 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n        peg$c77 = \"touchmove\",\n        peg$c78 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n        peg$c79 = \"touchend\",\n        peg$c80 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n        peg$c81 = function(e) { return e; },\n        peg$c82 = /^[a-zA-Z0-9_\\-]/,\n        peg$c83 = { type: \"class\", value: \"[a-zA-Z0-9_\\\\-]\", description: \"[a-zA-Z0-9_\\\\-]\" },\n        peg$c84 = function(n) { return n.join(\"\"); },\n        peg$c85 = /^[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]/,\n        peg$c86 = { type: \"class\", value: \"[a-zA-Z0-9\\\\-_  #.>+~[\\\\]=|\\\\^$*]\", description: \"[a-zA-Z0-9\\\\-_  #.>+~[\\\\]=|\\\\^$*]\" },\n        peg$c87 = function(c) { return c.join(\"\"); },\n        peg$c88 = /^['\"a-zA-Z0-9_().><=! \\t-&|~]/,\n        peg$c89 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_().><=! \\\\t-&|~]\", description: \"['\\\"a-zA-Z0-9_().><=! \\\\t-&|~]\" },\n        peg$c90 = function(v) { return v.join(\"\"); },\n        peg$c91 = /^[ \\t\\r\\n]/,\n        peg$c92 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemerged();\n\n      return s0;\n    }\n\n    function peg$parsemerged() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c1;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c2); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemerged();\n              if (s5 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c3(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseordered();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c4(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseordered() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefiltered();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c1;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c2); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsesep();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsefiltered();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsesep();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 93) {\n                        s9 = peg$c7;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parsesep();\n                        if (s10 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 62) {\n                            s11 = peg$c9;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parsesep();\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parseordered();\n                              if (s13 !== peg$FAILED) {\n                                peg$reportedPos = s0;\n                                s1 = peg$c11(s3, s7, s13);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$c0;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefiltered();\n      }\n\n      return s0;\n    }\n\n    function peg$parsefiltered() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsefilter();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsefilter();\n          }\n        } else {\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c13(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsestream();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c14(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsestream() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c15;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c16); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemerged();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c17;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c19(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 64) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsename();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseeventType();\n              if (s4 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c24(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemarkType();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s2 = peg$c22;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseeventType();\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c25(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecss();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s2 = peg$c22;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c23); }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseeventType();\n                if (s3 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c26(s1, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseeventType();\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c27(s1);\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsename();\n                if (s1 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c28(s1);\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsemarkType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 4) === peg$c29) {\n        s0 = peg$c29;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c31) {\n          s0 = peg$c31;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c33) {\n            s0 = peg$c33;\n            peg$currPos += 4;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c35) {\n              s0 = peg$c35;\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c36); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c37) {\n                s0 = peg$c37;\n                peg$currPos += 4;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c38); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 4) === peg$c39) {\n                  s0 = peg$c39;\n                  peg$currPos += 4;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c40); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 4) === peg$c41) {\n                    s0 = peg$c41;\n                    peg$currPos += 4;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c43) {\n                      s0 = peg$c43;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 4) === peg$c45) {\n                        s0 = peg$c45;\n                        peg$currPos += 4;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 5) === peg$c47) {\n                          s0 = peg$c47;\n                          peg$currPos += 5;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeventType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 9) === peg$c49) {\n        s0 = peg$c49;\n        peg$currPos += 9;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c51) {\n          s0 = peg$c51;\n          peg$currPos += 7;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c52); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c53) {\n            s0 = peg$c53;\n            peg$currPos += 5;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c54); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c55) {\n              s0 = peg$c55;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c56); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c57) {\n                s0 = peg$c57;\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c58); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c59) {\n                  s0 = peg$c59;\n                  peg$currPos += 7;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8) === peg$c61) {\n                    s0 = peg$c61;\n                    peg$currPos += 8;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c63) {\n                      s0 = peg$c63;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 10) === peg$c65) {\n                        s0 = peg$c65;\n                        peg$currPos += 10;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c66); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9) === peg$c67) {\n                          s0 = peg$c67;\n                          peg$currPos += 9;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c69) {\n                            s0 = peg$c69;\n                            peg$currPos += 8;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c70); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 9) === peg$c71) {\n                              s0 = peg$c71;\n                              peg$currPos += 9;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c72); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c73) {\n                                s0 = peg$c73;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c74); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 10) === peg$c75) {\n                                  s0 = peg$c75;\n                                  peg$currPos += 10;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c76); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 9) === peg$c77) {\n                                    s0 = peg$c77;\n                                    peg$currPos += 9;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c78); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 8) === peg$c79) {\n                                      s0 = peg$c79;\n                                      peg$currPos += 8;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c80); }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefilter() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c81(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsename() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c82.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c82.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c83); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c84(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecss() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c85.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c85.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c86); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c87(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseexpr() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c88.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c88.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c89); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c90(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesep() {\n      var s0, s1;\n\n      s0 = [];\n      if (peg$c91.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c91.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c92); }\n        }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();",
    "var expr = require('vega-expression'),\n    args = ['datum', 'event', 'signals'];\n\nmodule.exports = expr.compiler(args, {\n  idWhiteList: args,\n  fieldVar:    args[0],\n  globalVar:   args[2],\n  functions:   function(codegen) {\n    var fn = expr.functions(codegen);\n    fn.eventItem = function() { return 'event.vg.item'; };\n    fn.eventGroup = 'event.vg.getGroup';\n    fn.eventX = 'event.vg.getX';\n    fn.eventY = 'event.vg.getY';\n    fn.open = 'window.open';\n    return fn;\n  }\n});",
    "module.exports = {\n  axes:       require('./axes'),\n  background: require('./background'),\n  data:       require('./data'),\n  events:     require('./events'),\n  expr:       require('./expr'),\n  legends:    require('./legends'),\n  mark:       require('./mark'),\n  marks:      require('./marks'),\n  modify:     require('./modify'),\n  padding:    require('./padding'),\n  predicates: require('./predicates'),\n  properties: require('./properties'),\n  signals:    require('./signals'),\n  spec:       require('./spec'),\n  streams:    require('./streams'),\n  transforms: require('./transforms')\n};",
    "var lgnd = require('../scene/legend');\n\nfunction parseLegends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    parseLegend(def, index, legends[index], group);\n  });\n}\n\nfunction parseLegend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = parseLegends;",
    "var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nfunction parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n\n  return mark;\n}\n\nmodule.exports = parseMark;",
    "var parseMark = require('./mark'),\n    parseProperties = require('./properties');\n\nfunction parseRootMark(model, spec, width, height) {\n  return {\n    type:       'group',\n    width:      width,\n    height:     height,\n    properties: defaults(spec.scene || {}, model),\n    scales:     spec.scales  || [],\n    axes:       spec.axes    || [],\n    legends:    spec.legends || [],\n    marks:      (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n}\n\nvar PROPERTIES = [\n  'fill', 'fillOpacity', 'stroke', 'strokeOpacity',\n  'strokeWidth', 'strokeDash', 'strokeDashOffset'\n];\n\nfunction defaults(spec, model) {\n  var config = model.config().scene,\n      props = {}, i, n, m, p, s;\n\n  for (i=0, n=m=PROPERTIES.length; i<n; ++i) {\n    p = PROPERTIES[i];\n    if ((s=spec[p]) !== undefined) {\n      props[p] = s.signal ? s : {value: s};\n    } else if (config[p]) {\n      props[p] = {value: config[p]};\n    } else {\n      --m;\n    }\n  }\n\n  return m ? {update: parseProperties(model, 'group', props)} : {};\n}\n\nmodule.exports = parseRootMark;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Tuple = df.Tuple,\n    Deps = df.Dependencies;\n\nvar Types = {\n  INSERT: \"insert\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR:  \"clear\"\n};\n\nvar EMPTY = [];\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if (src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nfunction parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null,\n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate.name || def.predicate) : null,\n      reeval = (predicate === null),\n      isClear = def.type === Types.CLEAR,\n      node = new Node(model).router(isClear);\n\n  node.evaluate = function(input) {\n    if (predicate !== null) {  // TODO: predicate args\n      var db = model.values(Deps.DATA, predicate.data || EMPTY),\n          sg = model.values(Deps.SIGNALS, predicate.signals || EMPTY);\n      reeval = predicate.call(predicate, {}, db, sg, model._predicates);\n    }\n\n    log.debug(input, [def.type+\"ing\", reeval]);\n    if (!reeval || (!isClear && !input.signals[signalName])) return input;\n\n    var datum = {},\n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples.\n    if (def.type === Types.INSERT) {\n      t = Tuple.ingest(datum);\n      input.add.push(t);\n      d._data.push(t);\n    } else if (def.type === Types.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value; });\n    } else if (def.type === Types.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if (!(add.length || rem.length)) add.push(Tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1; });\n    } else if (def.type === Types.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    }\n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if (signalName) node.dependency(Deps.SIGNALS, signalName);\n\n  if (predicate) {\n    node.dependency(Deps.DATA, predicate.data);\n    node.dependency(Deps.SIGNALS, predicate.signals);\n  }\n\n  return node;\n}\n\nmodule.exports = parseModify;",
    "var dl = require('datalib');\n\nfunction parsePadding(pad) {\n  return pad == null ? 'auto' :\n    dl.isObject(pad) ? pad :\n    dl.isNumber(pad) ? {top:pad, left:pad, right:pad, bottom:pad} :\n    pad === 'strict' ? pad : 'auto';\n}\n\nmodule.exports = parsePadding;",
    "var dl = require('datalib');\n\nvar types = {\n  '=':   parseComparator,\n  '==':  parseComparator,\n  '!=':  parseComparator,\n  '>':   parseComparator,\n  '>=':  parseComparator,\n  '<':   parseComparator,\n  '<=':  parseComparator,\n  'and': parseLogical,\n  '&&':  parseLogical,\n  'or':  parseLogical,\n  '||':  parseLogical,\n  'in':  parseIn\n};\n\nvar nullScale = function() { return 0; };\nnullScale.invert = nullScale;\n\nfunction parsePredicates(model, spec) {\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](model, s);\n\n    /* jshint evil:true */\n    var pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0]; }; // For global scales\n    pred.nullScale = nullScale;\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n\nfunction parseSignal(signal, signals) {\n  var s = dl.field(signal),\n      code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n  signals[s[0]] = 1;\n  return code;\n}\n\nfunction parseOperands(model, operands) {\n  var decl = [], defs = [],\n      signals = {}, db = {};\n\n  function setSignal(s) { signals[s] = 1; }\n  function setData(d) { db[d] = 1; }\n\n  dl.array(operands).forEach(function(o, i) {\n    var name = \"o\" + i,\n        def = \"\";\n\n    if (o.value !== undefined) {\n      def = dl.str(o.value);\n    } else if (o.arg) {\n      def = \"args[\"+dl.str(o.arg)+\"]\";\n    } else if (o.signal) {\n      def = parseSignal(o.signal, signals);\n    } else if (o.predicate) {\n      var ref = o.predicate,\n          predName = ref && (ref.name || ref),\n          pred = model.predicate(predName),\n          p = \"predicates[\"+dl.str(predName)+\"]\";\n\n      pred.signals.forEach(setSignal);\n      pred.data.forEach(setData);\n\n      if (dl.isObject(ref)) {\n        dl.keys(ref).forEach(function(k) {\n          if (k === \"name\") return;\n          var i = ref[k];\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if (i.signal) {\n            def += parseSignal(i.signal, signals);\n          } else if (i.arg) {\n            def += \"args[\"+dl.str(i.arg)+\"]\";\n          }\n          def += \", \";\n        });\n      }\n\n      def += p+\".call(\"+p+\", args, db, signals, predicates)\";\n    }\n\n    decl.push(name);\n    defs.push(name+\"=(\"+def+\")\");\n  });\n\n  return {\n    code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n    signals: dl.keys(signals),\n    data: dl.keys(db)\n  };\n}\n\nfunction parseComparator(model, spec) {\n  var ops = parseOperands(model, spec.operands);\n  if (spec.type === '=') spec.type = '==';\n\n  ops.code += \"o0 = o0 instanceof Date ? o0.getTime() : o0;\\n\" +\n    \"o1 = o1 instanceof Date ? o1.getTime() : o1;\\n\";\n\n  return {\n    code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n    signals: ops.signals,\n    data: ops.data\n  };\n}\n\nfunction parseLogical(model, spec) {\n  var ops = parseOperands(model, spec.operands),\n      o = [], i = 0, len = spec.operands.length;\n\n  while (o.push(\"o\"+i++) < len);\n  if (spec.type === 'and') spec.type = '&&';\n  else if (spec.type === 'or') spec.type = '||';\n\n  return {\n    code: ops.code + \"return \" + o.join(spec.type) + \";\",\n    signals: ops.signals,\n    data: ops.data\n  };\n}\n\nfunction parseIn(model, spec) {\n  var o = [spec.item], code = \"\";\n  if (spec.range) o.push.apply(o, spec.range);\n  if (spec.scale) {\n    code = parseScale(spec.scale, o);\n  }\n\n  var ops = parseOperands(model, o);\n  code = ops.code + code + \"\\n  var ordSet = null;\\n\";\n\n  if (spec.data) {\n    var field = dl.field(spec.field).map(dl.str);\n    code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n    code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n  } else if (spec.range) {\n    // TODO: inclusive/exclusive range?\n    if (spec.scale) {\n      code += \"if (scale.length == 2) {\\n\" + // inverting ordinal scales\n        \"  ordSet = scale(o1, o2);\\n\" +\n        \"} else {\\n\" +\n        \"  o1 = scale(o1);\\no2 = scale(o2);\\n\" +\n        \"}\";\n    }\n\n    code += \"return ordSet !== null ? ordSet.indexOf(o0) !== -1 :\\n\" +\n      \"  o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1;\";\n  }\n\n  return {\n    code: code,\n    signals: ops.signals,\n    data: ops.data.concat(spec.data ? [spec.data] : [])\n  };\n}\n\n// Populate ops such that ultimate scale/inversion function will be in `scale` var.\nfunction parseScale(spec, ops) {\n  var code = \"var scale = \",\n      idx  = ops.length;\n\n  if (dl.isString(spec)) {\n    ops.push({ value: spec });\n    code += \"this.root().scale(o\"+idx+\")\";\n  } else if (spec.arg) {  // Scale function is being passed as an arg\n    ops.push(spec);\n    code += \"o\"+idx;\n  } else if (spec.name) { // Full scale parameter {name: ..}\n    ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n    code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n    if (spec.scope) {\n      ops.push(spec.scope);\n      code += \"((o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\") || this.nullScale)\";\n    } else {\n      code += \"this.root().scale(o\"+idx+\")\";\n    }\n    code += \")\";\n  }\n\n  if (spec.invert === true) {  // Allow spec.invert.arg?\n    code += \".invert\";\n  }\n\n  return code+\";\\n\";\n}\n\nmodule.exports = parsePredicates;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    log = require('vega-logging'),\n    Tuple = require('vega-dataflow').Tuple;\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction properties(model, mark, spec) {\n  var config = model.config(),\n      code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {},\n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        nested:  [],\n        _nRefs:  {},  // Temp stash to de-dupe nested refs.\n        reflow:  false\n      };\n\n  code += \"var o = trans ? {} : item, d=0, set=this.tpl.set, tmpl=signals||{}, t;\\n\" +\n          // Stash for dl.template\n          \"tmpl.datum  = item.datum;\\n\" +\n          \"tmpl.group  = group;\\n\" +\n          \"tmpl.parent = group.datum;\\n\";\n\n  function handleDep(p) {\n    if (ref[p] == null) return;\n    var k = dl.array(ref[p]), i, n;\n    for (i=0, n=k.length; i<n; ++i) {\n      deps[p][k[i]] = 1;\n    }\n  }\n\n  function handleNestedRefs(r) {\n    var k = (r.parent ? \"parent_\" : \"group_\")+r.level;\n    deps._nRefs[k] = r;\n  }\n\n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if (ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code;\n    } else if (dl.isArray(ref)) {\n      ref = rule(model, name, ref);\n      code += \"\\n  \" + ref.code;\n    } else {\n      ref = valueRef(config, name, ref);\n      code += \"d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(handleDep);\n    deps.reflow = deps.reflow || ref.reflow;\n    if (ref.nested.length) ref.nested.forEach(handleNestedRefs);\n  }\n\n  // If nested references are present, sort them based on their level\n  // to speed up determination of whether encoders should be reeval'd.\n  dl.keys(deps._nRefs).forEach(function(k) { deps.nested.push(deps._nRefs[k]); });\n  deps.nested.sort(function(a, b) {\n    a = a.level;\n    b = b.level;\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  });\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \" +\n              \"\\n    t = o.x;\" +\n              \"\\n    d += set(o, 'x', o.x2);\" +\n              \"\\n    d += set(o, 'x2', t); \" +\n              \"\\n  };\";\n      code += \"\\n  d += set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  d += set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  d += set(o, 'x', o.x2);\";\n    }\n  }\n\n  if (vars.xc) {\n    if (vars.width) {\n      code += \"\\n  d += set(o, 'x', (o.xc - o.width/2));\" ;\n    } else {\n      code += \"\\n  d += set(o, 'x', o.xc);\" ;\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \" +\n              \"\\n    t = o.y;\" +\n              \"\\n    d += set(o, 'y', o.y2);\" +\n              \"\\n    d += set(o, 'y2', t);\" +\n              \"\\n  };\";\n      code += \"\\n  d += set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  d += set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  d += set(o, 'y', o.y2);\";\n    }\n  }\n\n  if (vars.yc) {\n    if (vars.height) {\n      code += \"\\n  d += set(o, 'y', (o.yc - o.height/2));\" ;\n    } else {\n      code += \"\\n  d += set(o, 'y', o.yc);\" ;\n    }\n  }\n\n  if (hasPath(mark, vars)) code += \"\\n  d += (item.touch(), 1);\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n  code += \"\\n  return d > 0;\";\n\n  try {\n    /* jshint evil:true */\n    var encoder = Function('item', 'group', 'trans', 'db',\n      'signals', 'predicates', code);\n    encoder.tpl  = Tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    dl.extend(encoder, dl.template.context);\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      nested:  deps.nested,\n      reflow:  deps.reflow\n    };\n  } catch (e) {\n    log.error(e);\n    log.log(code);\n  }\n}\n\nfunction dependencies(a, b) {\n  if (!dl.isObject(a)) {\n    a = {reflow: false, nested: []};\n    DEPS.forEach(function(d) { a[d] = []; });\n  }\n\n  if (dl.isObject(b)) {\n    a.reflow = a.reflow || b.reflow;\n    a.nested.push.apply(a.nested, b.nested);\n    DEPS.forEach(function(d) { a[d].push.apply(a[d], b[d]); });\n  }\n\n  return a;\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark==='area' || mark==='line') &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var config  = model.config(),\n      deps = dependencies(),\n      inputs  = [], code = '';\n\n  (rules||[]).forEach(function(r, i) {\n    var def = r.predicate,\n        predName = def && (def.name || def),\n        pred = model.predicate(predName),\n        p = 'predicates['+dl.str(predName)+']',\n        input = [], args = name+'_arg'+i,\n        ref;\n\n    if (dl.isObject(def)) {\n      dl.keys(def).forEach(function(k) {\n        if (k === 'name') return;\n        var ref = valueRef(config, i, def[k]);\n        input.push(dl.str(k)+': '+ref.val);\n        dependencies(deps, ref);\n      });\n    }\n\n    ref = valueRef(config, name, r);\n    dependencies(deps, ref);\n\n    if (predName) {\n      deps.signals.push.apply(deps.signals, pred.signals);\n      deps.data.push.apply(deps.data, pred.data);\n      inputs.push(args+\" = {\\n    \"+input.join(\",\\n    \")+\"\\n  }\");\n      code += \"if (\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\" +\n        \"\\n    d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n      code += rules[i+1] ? \"\\n  } else \" : \"  }\";\n    } else {\n      code += \"{\" +\n        \"\\n    d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\"+\n        \"\\n  }\\n\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return (deps.code = code, deps);\n}\n\nfunction valueRef(config, name, ref) {\n  if (ref == null) return null;\n\n  if (name==='fill' || name==='stroke') {\n    if (ref.c) {\n      return colorRef(config, 'hcl', ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(config, 'hsl', ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(config, 'lab', ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(config, 'rgb', ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null,\n      deps = dependencies(),\n      sgRef = null, fRef = null, sRef = null, tmpl = {};\n\n  if (ref.template !== undefined) {\n    val = dl.template.source(ref.template, 'tmpl', tmpl);\n    dl.keys(tmpl).forEach(function(k) {\n      var f = dl.field(k),\n          a = f.shift();\n      if (a === 'parent' || a === 'group') {\n        deps.nested.push({\n          parent: a === 'parent',\n          group:  a === 'group',\n          level:  1\n        });\n      } else if (a === 'datum') {\n        deps.fields.push(f[0]);\n      } else {\n        deps.signals.push(a);\n      }\n    });\n  }\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = 'signals['+sgRef.map(dl.str).join('][')+']';\n    deps.signals.push(sgRef.shift());\n  }\n\n  if (ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef = fieldRef(ref.field);\n    val  = fRef.val;\n    dependencies(deps, fRef);\n  }\n\n  if (ref.scale !== undefined) {\n    sRef  = scaleRef(ref.scale);\n    scale = sRef.val;\n    dependencies(deps, sRef);\n    deps.scales.push(ref.scale.name || ref.scale);\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if (val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? '.rangeBand()' :\n        '('+(val !== null ? val : 'item.datum.data')+')');\n    } else {\n      val = scale;\n    }\n  }\n\n  // multiply, offset, return value\n  val = '(' + (ref.mult?(dl.number(ref.mult)+' * '):'') + val + ')' +\n        (ref.offset ? ' + ' + dl.number(ref.offset) : '');\n\n  // Collate dependencies\n  return (deps.val = val, deps);\n}\n\nfunction colorRef(config, type, x, y, z) {\n  var xx = x ? valueRef(config, '', x) : config.color[type][0],\n      yy = y ? valueRef(config, '', y) : config.color[type][1],\n      zz = z ? valueRef(config, '', z) : config.color[type][2],\n      deps = dependencies();\n\n  [xx, yy, zz].forEach(function(v) {\n    if (dl.isArray) return;\n    dependencies(deps, v);\n  });\n\n  var val = '(this.d3.' + type + '(' + [xx.val, yy.val, zz.val].join(',') + ') + \"\")';\n  return (deps.val = val, deps);\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if (dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join('][')};\n  }\n\n  // Resolve nesting/parent lookups\n  var l = ref.level || 1,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join('group.mark.') : '',\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      deps = dependencies(null, r);\n\n  if (ref.datum) {\n    val = 'item.datum['+val+']';\n    deps.fields.push(ref.datum);\n  } else if (ref.group) {\n    val = scope+'group['+val+']';\n    deps.nested.push({ level: l, group: true });\n  } else if (ref.parent) {\n    val = scope+'group.datum['+val+']';\n    deps.nested.push({ level: l, parent: true });\n  } else if (ref.signal) {\n    val = 'signals['+val+']';\n    deps.signals.push(dl.field(ref.signal)[0]);\n    deps.reflow = true;\n  }\n\n  return (deps.val = val, deps);\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null,\n      deps = dependencies();\n\n  if (dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if (ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = '(item.mark._scaleRefs['+scale+'] = 1, group.scale('+scale+'))';\n  if (ref.invert) scale += '.invert';\n\n  // Mark scale refs as they're dealt with separately in mark._scaleRefs.\n  if (fr) fr.nested.forEach(function(g) { g.scale = true; });\n  return fr ? (fr.val = scale, fr) : (deps.val = scale, deps);\n}\n\nmodule.exports = properties;",
    "var dl = require('datalib'),\n    SIGNALS = require('vega-dataflow').Dependencies.SIGNALS,\n    expr = require('./expr');\n\nvar RESERVED = ['datum', 'event', 'signals', 'width', 'height', 'padding']\n  .concat(dl.keys(expr.codegen.functions));\n\nfunction parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    if (RESERVED.indexOf(s.name) !== -1) {\n      throw Error('Signal name \"'+s.name+'\" is a '+\n        'reserved keyword ('+RESERVED.join(', ')+').');\n    }\n\n    var signal = model.signal(s.name, s.init)\n      .verbose(s.verbose);\n\n    if (s.init && s.init.expr) {\n      s.init.expr = expr(s.init.expr);\n      signal.value(exprVal(model, s.init));\n    }\n\n    if (s.expr) {\n      s.expr = expr(s.expr);\n      signal.evaluate = function(input) {\n        var val = exprVal(model, s),\n            sg  = input.signals;\n        if (val !== signal.value() || signal.verbose()) {\n          signal.value(val);\n          sg[s.name] = 1;\n        }\n        return sg[s.name] ? input : model.doNotPropagate;\n      };\n      signal.dependency(SIGNALS, s.expr.globals);\n      s.expr.globals.forEach(function(dep) {\n        model.signal(dep).addListener(signal);\n      });\n    }\n  });\n\n  return spec;\n}\n\nfunction exprVal(model, spec) {\n  var e = spec.expr,\n      val = e.fn(null, null, model.values(SIGNALS, e.globals));\n  return spec.scale ? parseSignals.scale(model, spec, val) : val;\n}\n\nparseSignals.scale = function scale(model, spec, value, datum, evt) {\n  var def = spec.scale,\n      name  = def.name || def.signal || def,\n      scope = def.scope, e;\n\n  if (scope) {\n    if (scope.signal) {\n      scope = model.signalRef(scope.signal);\n    } else if (dl.isString(scope)) { // Scope is an expression\n      e = def._expr = (def._expr || expr(scope));\n      scope = e.fn(datum, evt, model.values(SIGNALS, e.globals));\n    }\n  }\n\n  if (!scope || !scope.scale) {\n    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n  }\n\n  // Verify scope is valid\n  if (model.group(scope._id) !== scope) {\n    throw new Error('Scope for scale \"'+name+'\" is not a valid group item.');\n  }\n\n  var s = scope.scale(name);\n  return !s ? value : (def.invert ? s.invert(value) : s(value));\n};\n\nmodule.exports = parseSignals;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    Model = require('../core/Model'),\n    View = require('../core/View');\n\n/**\n * Parse graph specification\n * @param spec (object)\n * @param config (optional object)\n * @param viewFactory (optional function)\n * @param callback (error, model)\n */\n function parseSpec(spec /*, [config,] [viewFactory,] callback */) {\n  // do not assign any values to callback, as it will change arguments\n  var arglen = arguments.length,\n      argidx = 2,\n      cb = arguments[arglen-1],\n      model = new Model(),\n      viewFactory = View.factory;\n\n  if (arglen > argidx && dl.isFunction(arguments[arglen - argidx])) {\n    viewFactory = arguments[arglen - argidx];\n    ++argidx;\n  }\n  if (arglen > argidx && dl.isObject(arguments[arglen - argidx])) {\n    model.config(arguments[arglen - argidx]);\n  }\n\n  function onDone(err, value) {\n    if (cb) {\n      if (cb.length > 1) cb(err, value);\n      else if (!err) cb(value);\n      cb = null;\n    }\n  }\n\n  function onError(err) {\n    log.error(err);\n    onDone(err);\n  }\n\n  function onCreate(err) {\n    if (err) onError(err);\n    else onDone(null, viewFactory(model));\n  }\n\n  function parse(spec) {\n    try {\n      // protect against subsequent spec modification\n      spec = dl.duplicate(spec);\n\n      var parsers = require('./'),\n          width   = spec.width || 500,\n          height  = spec.height || 500,\n          padding = parsers.padding(spec.padding);\n\n      // create signals for width, height and padding\n      model.signal('width', width);\n      model.signal('height', height);\n      model.signal('padding', padding);\n\n      // initialize model\n      model.defs({\n        width:      width,\n        height:     height,\n        padding:    padding,\n        viewport:   spec.viewport || null,\n        background: parsers.background(spec.background),\n        signals:    parsers.signals(model, spec.signals),\n        predicates: parsers.predicates(model, spec.predicates),\n        marks:      parsers.marks(model, spec, width, height),\n        data:       parsers.data(model, spec.data, onCreate)\n      });\n    } catch (err) { onError(err); }\n  }\n\n  if (dl.isObject(spec)) {\n    parse(spec);\n  } else if (dl.isString(spec)) {\n    var opts = dl.extend({url: spec}, model.config().load);\n    dl.json(opts, function(err, spec) {\n      if (err) onError('SPECIFICATION LOAD FAILED: ' + err);\n      else parse(spec);\n    });\n  } else {\n    onError('INVALID SPECIFICATION: Must be a valid JSON object or URL.');\n  }\n}\n\nmodule.exports = parseSpec;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    SIGNALS = df.Dependencies.SIGNALS,\n    parseSignals = require('./signals'),\n    selector = require('./events'),\n    expr = require('./expr');\n\nvar GATEKEEPER = '_vgGATEKEEPER';\n\nvar vgEvent = {\n  getGroup: function(name) { return name ? this.name[name] : this.group; },\n  getXY: function(item) {\n      var p = {x: this.x, y: this.y};\n      if (typeof item === 'string') {\n        item = this.name[item];\n      }\n      for (; item; item = item.mark && item.mark.group) {\n        p.x -= item.x || 0;\n        p.y -= item.y || 0;\n      }\n      return p;\n    },\n  getX: function(item) { return this.getXY(item).x; },\n  getY: function(item) { return this.getXY(item).y; }\n};\n\nfunction parseStreams(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      registry = {handlers: {}, nodes: {}},\n      internal = dl.duplicate(registry),  // Internal event processing\n      external = dl.duplicate(registry);  // External event processing\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if (sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse.\n  dl.keys(internal.handlers).forEach(function(type) {\n    view.on(type, function(evt, item) {\n      evt.preventDefault(); // stop text selection\n      extendEvent(evt, item);\n      fire(internal, type, (item && item.datum) || {}, evt);\n    });\n  });\n\n  // add external event listeners\n  dl.keys(external.handlers).forEach(function(type) {\n    if (typeof window === 'undefined') return; // No external support\n\n    var h = external.handlers[type],\n        t = type.split(':'), // --> no element pseudo-selectors\n        elt = (t[0] === 'window') ? [window] :\n              window.document.querySelectorAll(t[0]);\n\n    function handler(evt) {\n      extendEvent(evt);\n      fire(external, type, d3.select(this).datum(), evt);\n    }\n\n    for (var i=0; i<elt.length; ++i) {\n      elt[i].addEventListener(t[1], handler);\n    }\n\n    h.elements = elt;\n    h.listener = handler;\n  });\n\n  // remove external event listeners\n  external.detach = function() {\n    dl.keys(external.handlers).forEach(function(type) {\n      var h = external.handlers[type],\n          t = type.split(':'),\n          elt = h.elements || [];\n\n      for (var i=0; i<elt.length; ++i) {\n        elt[i].removeEventListener(t[1], h.listener);\n      }\n    });\n  };\n\n  // export detach method\n  return external.detach;\n\n  // -- helper functions -----\n\n  function extendEvent(evt, item) {\n    var mouse = d3.mouse((d3.event=evt, view.renderer().scene())),\n        pad = view.padding(),\n        names = {}, mark, group, i;\n\n    if (item) {\n      mark = item.mark;\n      group = mark.marktype === 'group' ? item : mark.group;\n      for (i=item; i!=null; i=i.mark.group) {\n        if (i.mark.def.name) {\n          names[i.mark.def.name] = i;\n        }\n      }\n    }\n    names.root = view.model().scene().items[0];\n\n    evt.vg = Object.create(vgEvent);\n    evt.vg.group = group;\n    evt.vg.item = item || {};\n    evt.vg.name = names;\n    evt.vg.x = mouse[0] - pad.left;\n    evt.vg.y = mouse[1] - pad.top;\n  }\n\n  function fire(registry, type, datum, evt) {\n    var handlers = registry.handlers[type],\n        node = registry.nodes[type],\n        cs = df.ChangeSet.create(null, true),\n        filtered = false,\n        val, i, n, h;\n\n    function invoke(f) {\n      return !f.fn(datum, evt, model.values(SIGNALS, f.globals));\n    }\n\n    for (i=0, n=handlers.length; i<n; ++i) {\n      h = handlers[i];\n      filtered = h.filters.some(invoke);\n      if (filtered) continue;\n\n      val = h.exp.fn(datum, evt, model.values(SIGNALS, h.exp.globals));\n      if (h.spec.scale) {\n        val = parseSignals.scale(model, h.spec, val, datum, evt);\n      }\n\n      if (val !== h.signal.value() || h.signal.verbose()) {\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n    }\n\n    model.propagate(cs, node);\n  }\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if (s.event)       domEvent(sig, s, exp, spec);\n      else if (s.signal) signal(sig, s, exp, spec);\n      else if (s.start)  orderedStream(sig, s, exp, spec);\n      else if (s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  }\n\n  function domEvent(sig, selector, exp, spec) {\n    var evt = selector.event,\n        name = selector.name,\n        mark = selector.mark,\n        target   = selector.target,\n        filters  = selector.filters || [],\n        registry = target ? external : internal,\n        type = target ? target+':'+evt : evt,\n        node = registry.nodes[type] || (registry.nodes[type] = new df.Node(model)),\n        handlers = registry.handlers[type] || (registry.handlers[type] = []);\n\n    if (name) {\n      filters.push('!!event.vg.name[\"' + name + '\"]'); // Mimic event bubbling\n    } else if (mark) {\n      filters.push('event.vg.item.mark && event.vg.item.mark.marktype==='+dl.str(mark));\n    }\n\n    handlers.push({\n      signal: sig,\n      exp: exp,\n      spec: spec,\n      filters: filters.map(function(f) { return expr(f); })\n    });\n\n    node.addListener(sig);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new df.Node(model);\n    n.evaluate = function(input) {\n      if (!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = exp.fn(null, null, model.values(SIGNALS, exp.globals));\n      if (spec.scale) {\n        val = parseSignals.scale(model, spec, val);\n      }\n\n      if (val !== sig.value() || sig.verbose()) {\n        sig.value(val);\n        input.signals[sig.name()] = 1;\n        input.reflow = true;\n      }\n\n      return input;\n    };\n    n.dependency(df.Dependencies.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  }\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(),\n        gk = name + GATEKEEPER,\n        trueFn  = expr('true'),\n        falseFn = expr('false'),\n        middle  = selector.middle,\n        filters = middle.filters || (middle.filters = []),\n        gatekeeper = model.signal(gk) || model.signal(gk, false);\n\n    // Register an anonymous signal to act as a gatekeeper. Its value is\n    // true or false depending on whether the start or end streams occur.\n    // The middle signal then simply filters for the gatekeeper's value.\n    mergedStream(gatekeeper, [selector.start], trueFn, {});\n    mergedStream(gatekeeper, [selector.end], falseFn, {});\n\n    filters.push(gatekeeper.name());\n    mergedStream(sig, [selector.middle], exp, spec);\n  }\n}\n\nmodule.exports = parseStreams;",
    "var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nfunction parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    tx.param(k, def[k]);\n  });\n\n  return tx;\n}\n\nmodule.exports = parseTransforms;",
    "var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    scene = require('vega-scenegraph'),\n    Node = df.Node, // jshint ignore:line\n    log = require('vega-logging'),\n    bound = scene.bound,\n    Bounds = scene.Bounds,\n    Encoder = require('./Encoder');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph)\n    .router(true)\n    .reflows(true)\n    .mutates(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  log.debug(input, ['bounds', this._mark.marktype]);\n\n  var mark  = this._mark,\n      type  = mark.marktype,\n      isGrp = type === 'group',\n      items = mark.items,\n      hasLegends = dl.array(mark.def.legends).length > 0,\n      bounds  = mark.bounds,\n      rebound = !bounds || input.rem.length,\n      i, ilen, j, jlen, group, legend;\n\n  if (type === 'line' || type === 'area') {\n    bound.mark(mark, null, isGrp && !hasLegends);\n  } else {\n    input.add.forEach(function(item) {\n      bound.item(item);\n      rebound = rebound || (bounds && !bounds.encloses(item.bounds));\n    });\n\n    input.mod.forEach(function(item) {\n      rebound = rebound || (bounds && bounds.alignsWith(item.bounds));\n      bound.item(item);\n    });\n\n    if (rebound) {\n      bounds = mark.bounds && mark.bounds.clear() || (mark.bounds = new Bounds());\n      for (i=0, ilen=items.length; i<ilen; ++i) bounds.union(items[i].bounds);\n    }\n  }\n\n  if (isGrp && hasLegends) {\n    for (i=0, ilen=items.length; i<ilen; ++i) {\n      group = items[i];\n      group._legendPositions = null;\n      for (j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, 'legendPosition', legend.items, input.dirty);\n        bound.mark(legend, null, false);\n      }\n    }\n\n    bound.mark(mark, null, true);\n  }\n\n  return df.ChangeSet.create(input, true);\n};\n\nmodule.exports = Bounder;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    Item = require('vega-scenegraph').Item,\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    Tuple = df.Tuple,\n    ChangeSet = df.ChangeSet,\n    Sentinel = {},\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    parseData = require('../parse/data');\n\nfunction Builder() {\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar Status = Builder.STATUS = {\n  ENTER:  'enter',\n  UPDATE: 'update',\n  EXIT:   'exit'\n};\n\nvar CONNECTED = 1, DISCONNECTED = 2;\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n  this._status = null; // Connected or disconnected?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = (def.interactive !== false);\n  mark.items = [];\n  if (dl.isValid(def.name)) mark.name = def.name;\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if (def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain\n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== 'group');\n  this._encoder = new Encoder(this._graph, this._mark, this);\n  this._bounder = new Bounder(this._graph, this._mark);\n  this._output  = null; // Output changeset for reactive geom as Bounder reflows\n\n  if (this._ds) { this._encoder.dependency(Deps.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(Deps.DATA, this._encoder.dependency(Deps.DATA));\n  this.dependency(Deps.SCALES, this._encoder.dependency(Deps.SCALES));\n  this.dependency(Deps.SIGNALS, this._encoder.dependency(Deps.SIGNALS));\n\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here\n// because they need their group's data-joined context.\nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output, input;\n\n  if (geom) {\n    name = ['vg', this._parent_id, geom].join('_');\n    spec = {\n      name: name,\n      transform: from.transform,\n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = ['vg', this._from, this._def.type, src.listeners(true).length].join('_');\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var node;\n\n  if (geom) {\n    sibling = this.sibling(geom);\n\n    // Bounder reflows, so we need an intermediary node to propagate\n    // the output constructed by the Builder.\n    node = new Node(this._graph).addListener(this._ds.listener());\n    node.evaluate = function() { return sibling._output; };\n\n    if (sibling._isSuper) {\n      sibling.addListener(node);\n    } else {\n      sibling._bounder.addListener(node);\n    }\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources.\n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    output = this._ds.source().last();\n    input  = ChangeSet.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener(), output.stamp);\n  }\n}\n\nproto.ds = function() { return this._ds; };\nproto.parent   = function() { return this._parent; };\nproto.encoder  = function() { return this._encoder; };\nproto.pipeline = function() { return [this]; };\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder._scales.forEach(function(s) {\n    if (!(s = builder._parent.scale(s))) return;\n    s.addListener(builder);\n  });\n\n  if (this._parent) {\n    if (this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return (this._status = CONNECTED, this);\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if (!this._listeners.length) return this;\n\n  function disconnectScales(scales) {\n    for(var i=0, len=scales.length, s; i<len; ++i) {\n      if (!(s = builder._parent.scale(scales[i]))) continue;\n      s.removeListener(builder);\n    }\n  }\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  disconnectScales(this._encoder._scales);\n  disconnectScales(dl.keys(this._mark._scaleRefs));\n\n  return (this._status = DISCONNECTED, this);\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  log.debug(input, ['building', (this._from || this._def.from), this._def.type]);\n\n  var self = this,\n      def = this._mark.def,\n      props  = def.properties || {},\n      update = props.update   || {},\n      output = ChangeSet.create(input),\n      fullUpdate, fcs, data, name;\n\n  if (this._ds) {\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = output.data[(name=this._ds.name())];\n    output.data[name] = null;\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data[name] = data;\n\n    fcs = this._ds.last();\n    if (!fcs) throw Error('Builder evaluated before backing DataSource.');\n    if (fcs.stamp > this._stamp) {\n      join.call(this, fcs, output, this._ds.values(), true, fullUpdate);\n    } else if (fullUpdate) {\n      output.mod = this._mark.items.slice();\n    }\n  } else {\n    data = dl.isFunction(this._def.from) ? this._def.from() : [Sentinel];\n    join.call(this, input, output, data);\n  }\n\n  // Stash output before Bounder for downstream reactive geometry.\n  this._output = output = this._graph.evaluate(output, this._encoder);\n\n  // Add any new scale references to the dependency list, and ensure\n  // they're connected.\n  if (update.nested && update.nested.length && this._status === CONNECTED) {\n    dl.keys(this._mark._scaleRefs).forEach(function(s) {\n      var scale = self._parent.scale(s);\n      if (!scale) return;\n\n      scale.addListener(self);\n      self.dependency(Deps.SCALES, s);\n      self._encoder.dependency(Deps.SCALES, s);\n    });\n  }\n\n  // Supernodes calculate bounds too, but only on items marked dirty.\n  if (this._isSuper) {\n    output.mod = output.mod.filter(function(x) { return x._dirty; });\n    output = this._graph.evaluate(output, this._bounder);\n  }\n\n  return output;\n};\n\nfunction newItem() {\n  var item = Tuple.ingest(new Item(this._mark));\n\n  // For the root node's item\n  if (this._def.width)  Tuple.set(item, 'width',  this._def.width);\n  if (this._def.height) Tuple.set(item, 'height', this._def.height);\n  return item;\n}\n\nfunction join(input, output, data, ds, fullUpdate) {\n  var keyf = keyFunction(this._def.key || (ds ? '_id' : null)),\n      prev = this._mark.items || [],\n      rem  = ds ? input.rem : prev,\n      mod  = Tuple.idMap((!ds || fullUpdate) ? data : input.mod),\n      next = [],\n      i, key, len, item, datum, enter, diff;\n\n  // Only mark rems as exiting. Due to keyf, there may be an add/mod\n  // tuple that replaces it.\n  for (i=0, len=rem.length; i<len; ++i) {\n    item = (rem[i] === prev[i]) ? prev[i] :\n      keyf ? this._map[keyf(rem[i])] : rem[i];\n    item.status = Status.EXIT;\n  }\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? Status.ENTER : Status.UPDATE;\n    diff = !enter && item.datum !== datum;\n    item.datum = datum;\n\n    if (keyf) {\n      Tuple.set(item, 'key', key);\n      this._map[key] = item;\n    }\n\n    if (enter) {\n      output.add.push(item);\n    } else if (diff || mod[datum._id]) {\n      output.mod.push(item);\n    }\n\n    next.push(item);\n  }\n\n  for (i=0, len=rem.length; i<len; ++i) {\n    item = (rem[i] === prev[i]) ? prev[i] :\n      keyf ? this._map[key = keyf(rem[i])] : rem[i];\n    if (item.status === Status.EXIT) {\n      item._dirty = true;\n      input.dirty.push(item);\n      next.push(item);\n      output.rem.push(item);\n      if (keyf) this._map[key] = null;\n    }\n  }\n\n  return (this._mark.items = next, output);\n}\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s='', i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += '|';\n      s += String(f[i](d));\n    }\n    return s;\n  };\n}\n\nmodule.exports = Builder;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    bound = require('vega-scenegraph').bound;\n\nvar EMPTY = {};\n\nfunction Encoder(graph, mark, builder) {\n  var props  = mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit;\n\n  Node.prototype.init.call(this, graph);\n\n  this._mark = mark;\n  this._builder = builder;\n  var s = this._scales = [];\n\n  // Only scales used in the 'update' property set are set as\n  // encoder depedencies to have targeted reevaluations. However,\n  // we still want scales in 'enter' and 'exit' to be evaluated\n  // before the encoder.\n  if (enter) s.push.apply(s, enter.scales);\n\n  if (update) {\n    this.dependency(Deps.DATA, update.data);\n    this.dependency(Deps.SIGNALS, update.signals);\n    this.dependency(Deps.FIELDS, update.fields);\n    this.dependency(Deps.SCALES, update.scales);\n    s.push.apply(s, update.scales);\n  }\n\n  if (exit) s.push.apply(s, exit.scales);\n\n  return this.mutates(true);\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  log.debug(input, ['encoding', this._mark.def.type]);\n  var graph = this._graph,\n      props = this._mark.def.properties || {},\n      items = this._mark.items,\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      dirty  = input.dirty,\n      preds  = graph.predicates(),\n      req = input.request,\n      group = this._mark.group,\n      guide = group && (group.mark.axis || group.mark.legend),\n      db = EMPTY, sg = EMPTY, i, len, item, prop;\n\n  if (req && !guide) {\n    if ((prop = props[req]) && input.mod.length) {\n      db = prop.data ? graph.values(Deps.DATA, prop.data) : null;\n      sg = prop.signals ? graph.values(Deps.SIGNALS, prop.signals) : null;\n\n      for (i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds, dirty);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  db = values(Deps.DATA, graph, input, props);\n  sg = values(Deps.SIGNALS, graph, input, props);\n\n  // Items marked for removal are at the tail of items. Process them first.\n  for (i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if (exit) encode.call(this, exit, item, input.trans, db, sg, preds, dirty);\n    if (input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if (!input.trans) items.pop();\n  }\n\n  var update_status = require('./Builder').STATUS.UPDATE;\n  for (i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if (enter)  encode.call(this, enter,  item, input.trans, db, sg, preds, dirty);\n    if (update) encode.call(this, update, item, input.trans, db, sg, preds, dirty);\n    item.status = update_status;\n  }\n\n  if (update) {\n    for (i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds, dirty);\n    }\n  }\n\n  return input;\n};\n\n// Only marshal necessary data and signal values\nfunction values(type, graph, input, props) {\n  var p, x, o, add = input.add.length;\n  if ((p=props.enter) && (x=p[type]).length && add) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  if ((p=props.exit) && (x=p[type]).length && input.rem.length) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  if ((p=props.update) && (x=p[type]).length && (add || input.mod.length)) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  return o || EMPTY;\n}\n\nfunction encode(prop, item, trans, db, sg, preds, dirty) {\n  var enc = prop.encode,\n      wasDirty = item._dirty,\n      isDirty  = enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n\n  item._dirty = isDirty || wasDirty;\n  if (isDirty && !wasDirty) dirty.push(item);\n}\n\n// If a specified property set called, or update property set\n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var def = this._mark.def,\n      props = def.properties || {},\n      reeval = dl.isFunction(def.from) || def.orient || pulse.request ||\n        Node.prototype.reevaluate.call(this, pulse);\n\n  return reeval || (props.update ? nestedRefs.call(this) : false);\n};\n\n// Test if any nested refs trigger a reflow of mark items.\nfunction nestedRefs() {\n  var refs = this._mark.def.properties.update.nested,\n      parent = this._builder,\n      level = 0,\n      i = 0, len = refs.length,\n      ref, ds, stamp;\n\n  for (; i<len; ++i) {\n    ref = refs[i];\n\n    // Scale references are resolved via this._mark._scaleRefs which are\n    // added to dependency lists + connected in Builder.evaluate.\n    if (ref.scale) continue;\n\n    for (; level<ref.level; ++level) {\n      parent = parent.parent();\n      ds = parent.ds();\n    }\n\n    // Compare stamps to determine if a change in a group's properties\n    // or data should trigger a reeval. We cannot check anything fancier\n    // (e.g., pulse.fields) as the ref may use item.datum.\n    stamp = (ref.group ? parent.encoder() : ds.last())._stamp;\n    if (stamp > this._stamp) return true;\n  }\n\n  return false;\n}\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items, dirty) {\n  items = dl.array(items);\n  var preds = graph.predicates(),\n      db = graph.values(Deps.DATA),\n      sg = graph.values(Deps.SIGNALS),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds, dirty);\n      bound.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;",
    "var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    Collector = df.Collector,\n    log = require('vega-logging'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar Types = GroupBuilder.TYPES = {\n  GROUP:  \"group\",\n  MARK:   \"mark\",\n  AXIS:   \"axis\",\n  LEGEND: \"legend\"\n};\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def) {\n  var builder = this, name;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) {\n    s = builder.scale((name=s.name), new Scale(graph, s, builder));\n    builder.scale(name+\":prev\", s);\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(Deps.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function() {\n  var output  = Builder.prototype.evaluate.apply(this, arguments),\n      model   = this._graph,\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  output.rem.forEach(function(group) { model.group(group._id, null); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    });\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for (; i<len; ++i) {\n    child = children[i];\n    if (child.type == Types.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, j, c, len, group, pipeline, def, inline = false;\n\n  for (i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if (hasMarks) buildMarks.call(this, input, group);\n    if (hasAxes)  buildAxes.call(this, input, group);\n    if (hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node,\n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== Types.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined);\n      inline = inline && (pipeline[pipeline.length-1].listeners().length === 1); // Reactive geom source\n      inline = inline && (def.from && !def.from.mark); // Reactive geom target\n      c.inline = inline;\n\n      if (inline) this._graph.evaluate(input, c.builder);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  function removeTemp(c) {\n    if (c.type == Types.MARK && !c.inline &&\n        builder._graph.data(c.from) !== undefined) {\n      builder._recursor.removeListener(c.builder);\n    }\n  }\n\n  function updateAxis(a) {\n    var scale = a.scale();\n    if (!input.scales[scale.scaleName]) return;\n    a.reset().def();\n  }\n\n  function updateLegend(l) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke();\n    if (!input.scales[scale.scaleName]) return;\n    l.reset().def();\n  }\n\n  for (i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n\n    // Remove temporary connection for marks that draw from a source\n    if (hasMarks) builder._children[group._id].forEach(removeTemp);\n\n    // Update axis data defs\n    if (hasAxes) group.axes.forEach(updateAxis);\n\n    // Update legend data defs\n    if (hasLegends) group.legends.forEach(updateLegend);\n  }\n\n  function disconnectChildren(c) {\n    builder._recursor.removeListener(c.builder);\n    c.builder.disconnect();\n  }\n\n  for (i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(disconnectChildren);\n    delete builder._children[group._id];\n  }\n\n  return input;\n}\n\nfunction scale(name, x) {\n  var group = this, s = null;\n  if (arguments.length === 2) return (group._scales[name] = x, x);\n  while (s == null) {\n    s = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if (!group) break;\n  }\n  return s;\n}\n\nfunction buildGroup(input, group) {\n  log.debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};\n  group.scale = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n\n  // Index group by ID to enable safe scoped scale lookups.\n  this._graph.group(group._id, group);\n}\n\nfunction buildMarks(input, group) {\n  log.debug(input, [\"building children marks #\"+group._id]);\n  var marks = this._def.marks,\n      mark, from, inherit, i, len, b;\n\n  for (i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = group.datum._facetID;\n    group.items[i] = {group: group, _scaleRefs: {}};\n    b = (mark.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({\n      builder: b,\n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit),\n      type: Types.MARK\n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axis: a, layer: def.layer};\n    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(Deps.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: Types.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legend: l};\n    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(Deps.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: Types.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    Aggregate = require('../transforms/Aggregate');\n\nvar Properties = {\n  width: 1,\n  height: 1\n};\n\nvar Types = {\n  LINEAR: 'linear',\n  ORDINAL: 'ordinal',\n  LOG: 'log',\n  POWER: 'pow',\n  SQRT: 'sqrt',\n  TIME: 'time',\n  TIME_UTC: 'utc',\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold'\n};\n\nvar DataRef = {\n  DOMAIN: 'domain',\n  RANGE: 'range',\n\n  COUNT: 'count',\n  GROUPBY: 'groupby',\n  MIN: 'min',\n  MAX: 'max',\n  VALUE: 'value',\n\n  ASC: 'asc',\n  DESC: 'desc'\n};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph).reflows(true);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times.\n  if (this._updated) {\n    input.scales[this._def.name] = 1;\n    log.debug(input, [\"scale\", this._def.name]);\n  }\n  return df.ChangeSet.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    var method = (type === Deps.DATA ? 'data' : 'signal');\n    deps = dl.array(deps);\n    for (var i=0, len=deps.length; i<len; ++i) {\n      this._graph[method](deps[i]).addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + ':prev',\n      s = instance.call(this, group.scale(name)),\n      m = s.type===Types.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var config = this._graph.config(),\n      type = this._def.type || Types.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) throw Error('Unrecognized scale type: ' + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      dataDrivenRange = false,\n      pad = signal.call(this, def.padding) || 0,\n      outer = def.outerPadding == null ? pad : signal.call(this, def.outerPadding),\n      points = def.points && signal.call(this, def.points),\n      round = signal.call(this, def.round) || def.round == null,\n      domain, str, spatial=true;\n\n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, DataRef.RANGE, def.range, scale, group);\n  }\n\n  // domain\n  domain = dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  }\n\n  // range\n  if (!dl.equal(prev.range, rng)) {\n    // width-defined range\n    if (def.bandWidth) {\n      var bw = signal.call(this, def.bandWidth),\n          len = domain.length,\n          space = def.points ? (pad*bw) : (pad*bw*(len-1) + 2*outer),\n          start;\n      if (rng[0] > rng[1]) {\n        start = rng[1] || 0;\n        rng = [start + (bw * len + space), start];\n      } else {\n        start = rng[0] || 0;\n        rng = [start, start + (bw * len + space)];\n      }\n    }\n\n    str = typeof rng[0] === 'string';\n    if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n      scale.range(rng); // color or shape values\n      spatial = false;\n    } else if (points && round) {\n      scale.rangeRoundPoints(rng, pad);\n    } else if (points) {\n      scale.rangePoints(rng, pad);\n    } else if (round) {\n      scale.rangeRoundBands(rng, pad, outer);\n    } else {\n      scale.rangeBands(rng, pad, outer);\n    }\n\n    prev.range = rng;\n    this._updated = true;\n  }\n\n  if (!scale.invert && spatial) invertOrdinal(scale);\n}\n\n// \"Polyfill\" ordinal scale inversion. Currently, only ordinal scales\n// with ordered numeric ranges are supported.\nvar bisect = d3.bisector(dl.numcmp).right,\n    findAsc = function(a, x) { return bisect(a,x) - 1; },\n    findDsc = d3.bisector(function(a,b) { return -1 * dl.numcmp(a,b); }).left;\n\nfunction invertOrdinal(scale) {\n  scale.invert = function(x, y) {\n    var rng = scale.range(),\n        asc = rng[0] < rng[1],\n        find = asc ? findAsc : findDsc;\n\n    if (arguments.length === 1) {\n      if (!dl.isNumber(x)) {\n        throw Error('Ordinal scale inversion is only supported for numeric input ('+x+').');\n      }\n      return scale.domain()[find(rng, x)];\n\n    } else if (arguments.length === 2) {  // Invert extents\n      if (!dl.isNumber(x) || !dl.isNumber(y)) {\n        throw Error('Extents to ordinal invert are not numbers ('+x+', '+y+').');\n      }\n\n      var domain = scale.domain(),\n          a = find(rng, x),\n          b = find(rng, y),\n          n = rng.length - 1, r;\n      if (b < a) { r = a; a = b; b = a; } // ensure a <= b\n      if (a < 0) a = 0;\n      if (b > n) b = n;\n\n      return (asc ? dl.range(a, b+1) : dl.range(b, a-1, -1))\n        .map(function(i) { return domain[i]; });\n    }\n  };\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      round = signal.call(this, def.round),\n      exponent = signal.call(this, def.exponent),\n      clamp = signal.call(this, def.clamp),\n      nice = signal.call(this, def.nice),\n      domain, interval;\n\n  // domain\n  domain = (def.type === Types.QUANTILE) ?\n    dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group) :\n    domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  }\n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (signal.call(this, def.range) === 'height') rng = rng.reverse();\n  if (rng && !dl.equal(prev.range, rng)) {\n    scale[round && scale.rangeRound ? 'rangeRound' : 'range'](rng);\n    prev.range = rng;\n    this._updated = true;\n  }\n\n  if (exponent && def.type===Types.POWER) scale.exponent(exponent);\n  if (clamp) scale.clamp(true);\n  if (nice) {\n    if (def.type === Types.TIME) {\n      interval = d3.time[nice];\n      if (!interval) log.error('Unrecognized interval: ' + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction isUniques(scale) {\n  return scale.type === Types.ORDINAL || scale.type === Types.QUANTILE;\n}\n\nfunction getRefs(def) {\n  return def.fields || dl.array(def);\n}\n\nfunction inherits(refs) {\n  return refs.some(function(r) {\n    if (!r.data) return true;\n    return r.data && dl.array(r.field).some(function(f) {\n      return f.parent;\n    });\n  });\n}\n\nfunction getFields(ref, group) {\n  return dl.array(ref.field).map(function(f) {\n    return f.parent ?\n      dl.accessor(f.parent)(group.datum) :\n      f; // String or {'signal'}\n  });\n}\n\n// Scale datarefs can be computed over multiple schema types.\n// This function determines the type of aggregator created, and\n// what data is sent to it: values, tuples, or multi-tuples that must\n// be standardized into a consistent schema.\nfunction aggrType(def, scale) {\n  var refs = getRefs(def);\n\n  // If we're operating over only a single domain, send full tuples\n  // through for efficiency (fewer accessor creations/calls)\n  if (refs.length == 1 && dl.array(refs[0].field).length == 1) {\n    return Aggregate.TYPES.TUPLE;\n  }\n\n  // With quantitative scales, we only care about min/max.\n  if (!isUniques(scale)) return Aggregate.TYPES.VALUE;\n\n  // If we don't sort, then we can send values directly to aggrs as well\n  if (!dl.isObject(def.sort)) return Aggregate.TYPES.VALUE;\n\n  return Aggregate.TYPES.MULTI;\n}\n\nfunction getCache(which, def, scale, group) {\n  var refs = getRefs(def),\n      inherit = inherits(refs),\n      atype = aggrType(def, scale),\n      uniques = isUniques(scale),\n      sort = def.sort,\n      ck = '_'+which,\n      fields = getFields(refs[0], group);\n\n  if (scale[ck] || this[ck]) return scale[ck] || this[ck];\n\n  var cache = new Aggregate(this._graph).type(atype),\n      groupby, summarize;\n\n  // If a scale's dataref doesn't inherit data from the group, we can\n  // store the dataref aggregator at the Scale (dataflow node) level.\n  if (inherit) {\n    scale[ck] = cache;\n  } else {\n    this[ck]  = cache;\n  }\n\n  if (uniques) {\n    if (atype === Aggregate.TYPES.VALUE) {\n      groupby = [{ name: DataRef.GROUPBY, get: dl.identity }];\n      summarize = {'*': DataRef.COUNT};\n    } else if (atype === Aggregate.TYPES.TUPLE) {\n      groupby = [{ name: DataRef.GROUPBY, get: dl.$(fields[0]) }];\n      summarize = dl.isObject(sort) ? [{\n        field: DataRef.VALUE,\n        get:  dl.$(sort.field),\n        ops: [sort.op]\n      }] : {'*': DataRef.COUNT};\n    } else {  // atype === Aggregate.TYPES.MULTI\n      groupby   = DataRef.GROUPBY;\n      summarize = [{ field: DataRef.VALUE, ops: [sort.op] }];\n    }\n  } else {\n    groupby = [];\n    summarize = [{\n      field: DataRef.VALUE,\n      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,\n      ops: [DataRef.MIN, DataRef.MAX],\n      as:  [DataRef.MIN, DataRef.MAX]\n    }];\n  }\n\n  cache.param('groupby', groupby)\n    .param('summarize', summarize);\n\n  return (cache._lastUpdate = -1, cache);\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = getRefs(def),\n      inherit = inherits(refs),\n      atype = aggrType(def, scale),\n      cache = getCache.apply(this, arguments),\n      sort  = def.sort,\n      uniques = isUniques(scale),\n      i, rlen, j, flen, ref, fields, field, data, from, cmp;\n\n  function addDep(s) {\n    self.dependency(Deps.SIGNALS, s);\n  }\n\n  if (inherit || (!inherit && cache._lastUpdate < this._stamp)) {\n    for (i=0, rlen=refs.length; i<rlen; ++i) {\n      ref = refs[i];\n      from = ref.data || group.datum._facetID;\n      data = graph.data(from).last();\n\n      if (data.stamp <= this._stamp) continue;\n\n      fields = getFields(ref, group);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        field = fields[j];\n\n        if (atype === Aggregate.TYPES.VALUE) {\n          cache.accessors(null, field);\n        } else if (atype === Aggregate.TYPES.MULTI) {\n          cache.accessors(field, ref.sort || sort.field);\n        } // Else (Tuple-case) is handled by the aggregator accessors by default\n\n        cache.evaluate(data);\n      }\n\n      this.dependency(Deps.DATA, from);\n      cache.dependency(Deps.SIGNALS).forEach(addDep);\n    }\n\n    cache._lastUpdate = this._stamp;\n\n    data = cache.aggr().result();\n    if (uniques) {\n      if (dl.isObject(sort)) {\n        cmp = sort.op + '_' + DataRef.VALUE;\n        cmp = dl.comparator(cmp);\n      } else if (sort === true) {\n        cmp = dl.comparator(DataRef.GROUPBY);\n      }\n\n      if (cmp) data = data.sort(cmp);\n      cache._values = data.map(function(d) { return d[DataRef.GROUPBY]; });\n    } else {\n      data = data[0];\n      cache._values = !dl.isValid(data) ? [] : [data[DataRef.MIN], data[DataRef.MAX]];\n    }\n  }\n\n  return cache._values;\n}\n\nfunction signal(v) {\n  if (!v || !v.signal) return v;\n  var s = v.signal, ref;\n  this.dependency(Deps.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], s, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = dl.isValid(s=signal.call(this, def.domainMin)) ? s : domain[0];\n      } else {\n        domain[0] = dataRef.call(this, DataRef.DOMAIN+DataRef.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = dl.isValid(s=signal.call(this, def.domainMax)) ? s : domain[z];\n      } else {\n        domain[z] = dataRef.call(this, DataRef.DOMAIN+DataRef.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== Types.LOG && def.type !== Types.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      config = this._graph.config(),\n      rangeVal = signal.call(this, def.range),\n      rng = [null, null];\n\n  if (rangeVal !== undefined) {\n    if (typeof rangeVal === 'string') {\n      if (Properties[rangeVal]) {\n        rng = [0, group[rangeVal]];\n      } else if (config.range[rangeVal]) {\n        rng = config.range[rangeVal];\n      } else {\n        log.error('Unrecogized range: ' + rangeVal);\n        return rng;\n      }\n    } else if (dl.isArray(rangeVal)) {\n      rng = dl.duplicate(rangeVal).map(signal.bind(this));\n    } else if (dl.isObject(rangeVal)) {\n      return null; // early exit\n    } else {\n      rng = [0, rangeVal];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ?\n      signal.call(this, def.rangeMin) :\n      def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ?\n      signal.call(this, def.rangeMax) :\n      def.rangeMax;\n  }\n\n  if (def.reverse !== undefined) {\n    var rev = signal.call(this, def.reverse);\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n\n  return rng;\n}\n\nmodule.exports = Scale;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    bound = require('vega-scenegraph').bound,\n    Tuple = require('vega-dataflow').Tuple,\n    Status = require('./Builder').STATUS;\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease('cubic-in-out');\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  'text': 1,\n  'url':  1\n};\n\nprototype.interpolate = function(item, values) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];\n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        Tuple.set(item, key, next);\n      } else if (typeof curr === 'number' && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        Tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === Status.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === Status.EXIT) {\n      // Only mark item as exited when it is removed.\n      curr.item.status = Status.UPDATE;\n      curr.remove = true;\n    }\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    bound.item(item);\n\n    if (f === 1) {\n      if (curr.remove) {\n        item.status = Status.EXIT;\n        item.remove();\n      }\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n}\n\nmodule.exports = Transition;",
    "var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    parseMark = require('../parse/mark');\n\nvar axisBounds = new (require('vega-scenegraph').Bounds)();\n\nvar TIME    = 'time',\n    UTC     = 'utc',\n    STRING  = 'string',\n    ORDINAL = 'ordinal',\n    NUMBER  = 'number';\n\nfunction axs(model) {\n  var scale,\n      config = model.config().axis,\n      orient = config.orient,\n      offset = 0,\n      titleOffset = config.titleOffset,\n      axisDef = {},\n      layer = 'front',\n      grid = false,\n      title = null,\n      tickMajorSize = config.tickSize,\n      tickMinorSize = config.tickSize,\n      tickEndSize = config.tickSize,\n      tickPadding = config.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormatType = null,\n      tickSubdivide = 0,\n      tickCount = config.ticks,\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  {},\n        majorTicks: {},\n        minorTicks: {},\n        tickLabels: {},\n        domain: {},\n        title:  {}\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  }\n\n  function ingest(d) {\n    return {data: d};\n  }\n\n  function getTickFormat() {\n    var formatType = tickFormatType || inferFormatType();\n    return getFormatter(formatType, tickFormatString);\n  }\n\n  function inferFormatType() {\n    switch (scale.type) {\n      case TIME:    return TIME;\n      case UTC:     return UTC;\n      case ORDINAL: return STRING;\n      default:      return NUMBER;\n    }\n  }\n\n  // Adapted from d3 log scale\n  // TODO customize? replace with range-size-aware filtering?\n  function logFilter(domain, count, f) {\n    if (count == null) return f;\n    var base = scale.base(),\n        k = Math.min(base, scale.ticks().length / count),\n        v = domain[0] > 0 ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),\n        e;\n    function log(x) {\n      return (domain[0] < 0 ?\n        -Math.log(x > 0 ? 0 : -x) :\n        Math.log(x < 0 ? 0 : x)) / Math.log(base);\n    }\n    function pow(x) {\n      return domain[0] < 0 ? -Math.pow(base, -x) : Math.pow(base, x);\n    }\n    return function(d) {\n      return pow(v(log(d) + e)) / d >= k ? f(d) : '';\n    };\n  }\n\n  function getFormatter(formatType, str) {\n    var fmt = dl.format,\n        log = scale.type === 'log',\n        domain;\n\n    switch (formatType) {\n      case NUMBER:\n        domain = scale.domain();\n        return log ?\n          logFilter(domain, tickCount, fmt.auto.number(str || null)) :\n          fmt.auto.linear(domain, tickCount, str || null);\n      case TIME: return (str ? fmt : fmt.auto).time(str);\n      case UTC:  return (str ? fmt : fmt.auto).utc(str);\n      default:   return String;\n    }\n  }\n\n  function getTicks(format) {\n    var major = tickValues || (scale.ticks ? scale.ticks(tickCount) : scale.domain()),\n        minor = axisSubdivide(scale, major, tickSubdivide).map(ingest);\n    major = major.map(function(d) { return (d = ingest(d), d.label = format(d.data), d); });\n    return [major, minor];\n  }\n\n  axis.def = function() {\n    if (!axisDef.type) axis_def(scale);\n\n    var ticks = getTicks(getTickFormat());\n    var tdata = title ? [title].map(ingest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? ticks[0] : []; };\n    axisDef.marks[1].from = function() { return ticks[0]; };\n    axisDef.marks[2].from = function() { return ticks[1]; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    if (titleOffset === 'auto') titleAutoOffset(axisDef);\n\n    return axisDef;\n  };\n\n  function titleAutoOffset(axisDef) {\n    var orient = axisDef.orient,\n        update = axisDef.marks[5].properties.update,\n        fn = update.encode,\n        min = config.titleOffsetAutoMin,\n        max = config.titleOffsetAutoMax,\n        pad = config.titleOffsetAutoMargin;\n\n    // Offset axis title using bounding box of axis domain and labels\n    // Assumes other components are **encoded and bounded** beforehand\n    update.encode = function(item, group, trans, db, signals, preds) {\n      var dirty = fn.call(fn, item, group, trans, db, signals, preds),\n          field = (orient==='bottom' || orient==='top') ? 'y' : 'x';\n      if (titleStyle[field] != null) return dirty;\n\n      axisBounds.clear()\n        .union(group.items[3].bounds)\n        .union(group.items[4].bounds);\n\n      var o = trans ? {} : item,\n          method = (orient==='left' || orient==='right') ? 'width' : 'height',\n          sign = (orient==='top' || orient==='left') ? -1 : 1,\n          off = ~~(axisBounds[method]() + item.fontSize/2 + pad);\n\n      Tuple.set(o, field, sign * Math.min(Math.max(min, off), max));\n      if (trans) trans.interpolate(item, o);\n      return true;\n    };\n  }\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === ORDINAL) {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+':prev', offset: 0.5};\n    }\n    range = axisScaleRange(scale);\n\n    // setup axis marks\n    dl.extend(m.gridLines, axisTicks(config));\n    dl.extend(m.majorTicks, axisTicks(config));\n    dl.extend(m.minorTicks, axisTicks(config));\n    dl.extend(m.tickLabels, axisTickLabels(config));\n    dl.extend(m.domain, axisDomain(config));\n    dl.extend(m.title, axisTitle(config));\n    m.gridLines.properties.enter.stroke = {value: config.gridColor};\n    m.gridLines.properties.enter.strokeOpacity = {value: config.gridOpacity};\n\n    // extend axis marks based on axis orientation\n    axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    axisDomainExtend(orient, m.domain, range, tickEndSize);\n    axisTitleExtend(orient, m.title, range, +titleOffset || -1);\n\n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: {\n          encode: axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  }\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in axisOrients ? x + '' : config.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.tickCount = function(x) {\n    if (!arguments.length) return tickCount;\n    tickCount = x;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.tickFormatType = function(x) {\n    if (!arguments.length) return tickFormatType;\n    if (tickFormatType !== x) {\n      tickFormatType = x;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n\n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== x) { titleOffset = x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n\n  axis.reset = function() {\n    reset();\n    return axis;\n  };\n\n  return axis;\n}\n\nvar axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction axisSubdivide(scale, ticks, m) {\n  var subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = axisScaleExtent(scale.domain()),\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction axisScaleRange(scale) {\n  return scale.rangeExtent ?\n    scale.rangeExtent() :\n    axisScaleExtent(scale.range());\n}\n\nvar axisAlign = {\n  bottom: 'center',\n  top: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nvar axisBaseline = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'middle',\n  right: 'middle'\n};\n\nfunction axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === 'left' || orient === 'top') {\n    size *= -1;\n  }\n  if (orient === 'top' || orient === 'bottom') {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: 'center'},\n      baseline: {value: axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: axisAlign[orient]},\n      baseline: {value: 'middle'}\n    });\n  }\n}\n\nfunction axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === 'left' || orient === 'top') ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === 'top' || orient === 'bottom') ?\n      {field: {group: 'height', level: 2}, mult: -sign} :\n      {field: {group: 'width',  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === 'top' || orient === 'bottom') {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });\n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction axisTitleExtend(orient, title, range, offset) {\n  var update = title.properties.update,\n      mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === 'top' || orient === 'left') ? -1 : 1;\n\n  if (orient === 'bottom' || orient === 'top') {\n    update.x = {value: mid};\n    update.angle = {value: 0};\n    if (offset >= 0) update.y = sign * offset;\n  } else {\n    update.y = {value: mid};\n    update.angle = {value: orient === 'left' ? -90 : 90};\n    if (offset >= 0) update.x = sign * offset;\n  }\n}\n\nfunction axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === 'top' || orient === 'left') {\n    size = -1 * size;\n  }\n  if (orient === 'bottom' || orient === 'top') {\n    path = 'M' + range[0] + ',' + size + 'V0H' + range[1] + 'V' + size;\n  } else {\n    path = 'M' + size + ',' + range[0] + 'H0V' + range[1] + 'H' + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction axisUpdate(item, group, trans) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isArray(offset)) {\n    var ofx = offset[0],\n        ofy = offset[1];\n\n    switch (orient) {\n      case 'left':   { Tuple.set(o, 'x', -ofx); Tuple.set(o, 'y', ofy); break; }\n      case 'right':  { Tuple.set(o, 'x', width + ofx); Tuple.set(o, 'y', ofy); break; }\n      case 'bottom': { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', height + ofy); break; }\n      case 'top':    { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', -ofy); break; }\n      default:       { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', ofy); }\n    }\n  } else {\n    if (dl.isObject(offset)) {\n      offset = -group.scale(offset.scale)(offset.value);\n    }\n\n    switch (orient) {\n      case 'left':   { Tuple.set(o, 'x', -offset); Tuple.set(o, 'y', 0); break; }\n      case 'right':  { Tuple.set(o, 'x', width + offset); Tuple.set(o, 'y', 0); break; }\n      case 'bottom': { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', height + offset); break; }\n      case 'top':    { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', -offset); break; }\n      default:       { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', 0); }\n    }\n  }\n\n  if (trans) trans.interpolate(item, o);\n  return true;\n}\n\nfunction axisTicks(config) {\n  return {\n    type: 'rule',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        stroke: {value: config.tickColor},\n        strokeWidth: {value: config.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction axisTickLabels(config) {\n  return {\n    type: 'text',\n    interactive: true,\n    key: 'data',\n    properties: {\n      enter: {\n        fill: {value: config.tickLabelColor},\n        font: {value: config.tickLabelFont},\n        fontSize: {value: config.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: 'label'}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction axisTitle(config) {\n  return {\n    type: 'text',\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.titleFont},\n        fontSize: {value: config.titleFontSize},\n        fontWeight: {value: config.titleFontWeight},\n        fill: {value: config.titleColor},\n        align: {value: 'center'},\n        baseline: {value: 'middle'},\n        text: {field: 'data'}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction axisDomain(config) {\n  return {\n    type: 'path',\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axisColor},\n        strokeWidth: {value: config.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    Gradient = require('vega-scenegraph').Gradient,\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark');\n\nfunction lgnd(model) {\n  var size = null,\n      shape = null,\n      fill = null,\n      stroke = null,\n      spacing = null,\n      values = null,\n      format = null,\n      formatString = null,\n      config = model.config().legend,\n      title,\n      orient = config.orient,\n      offset = config.offset,\n      padding = config.padding,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  {},\n        symbols: {},\n        labels:  {},\n        gradient: {}\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i}; }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n\n    format = !formatString ? null : ((scale.type === 'time') ?\n      dl.format.time(formatString) : dl.format.number(formatString));\n\n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type) ?\n        quantDef(scale) : ordinalDef(scale);\n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    legendDef.margin = config.margin;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type==='ordinal' || type==='quantize' ||\n           type==='quantile' || type==='threshold';\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null ?\n      (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :\n      values).map(ingest);\n    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.symbolSize));\n      range = spacing ||\n        (fs = labelStyle.fontSize) && (fs.value + pad) ||\n        (config.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n\n    // build scale for label layout\n    def.scales = def.scales || [{}];\n    dl.extend(def.scales[0], {\n      name: 'legend',\n      type: 'ordinal',\n      points: true,\n      domain: domain,\n      range: range\n    });\n\n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = dl.extend(m.titles, legendTitle(config)),\n        symbols = dl.extend(m.symbols, legendSymbols(config)),\n        labels  = dl.extend(m.labels, vLegendLabels(config));\n\n    // extend legend marks\n    legendSymbolExtend(symbols, size, shape, fill, stroke);\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, 'group', legendStyle),\n        legendPosition: {\n          encode: legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data  = (values == null ? dom : values).map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.gradientWidth,\n        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // build scale for label layout\n    def.scales = def.scales || [{}];\n    var layoutSpec = dl.extend(def.scales[0], {\n      name: 'legend',\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    });\n    if (scale.type==='pow') layoutSpec.exponent = scale.exponent();\n\n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? 'right' : i===0 ? 'left' : 'center';\n    });\n\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n\n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = dl.extend(m.titles, legendTitle(config)),\n        gradient = dl.extend(m.gradient, legendGradient(config)),\n        labels = dl.extend(m.labels, hLegendLabels(config)),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n\n    var stops = (scale.type !== 'linear' && scale.ticks) ?\n      scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, 'group', legendStyle),\n        legendPosition: {\n          encode: legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n\n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in LEGEND_ORIENT ? x + '' : config.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n\n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() {\n    reset();\n    return legend;\n  };\n\n  return legend;\n}\n\nvar LEGEND_ORIENT = {right: 1, left: 1};\n\nfunction legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, i, aw = 0,\n      def    = item.mark.def,\n      offset = def.offset,\n      orient = def.orient,\n      pad    = def.padding * 2,\n      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions ||\n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh) + def.margin;\n\n  for (i=0; i<group.axes.length; ++i) {\n    if (group.axes[i].orient() === orient) {\n      aw = Math.max(aw, group.axisItems[i].bounds.width());\n    }\n  }\n\n  if (orient === 'left') {\n    o.x -= aw + offset + lw;\n  } else {\n    o.x += group.width + aw + offset;\n  }\n\n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans, db, signals, predicates);\n  return true;\n}\n\nfunction legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: 'data'};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: 'data'};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: 'data'};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: 'data'};\n}\n\nfunction legendTitle(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: config.titleColor},\n        font: {value: config.titleFont},\n        fontSize: {value: config.titleFontSize},\n        fontWeight: {value: config.titleFontWeight},\n        baseline: {value: 'top'},\n        text: {field: 'data'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction legendSymbols(config) {\n  return {\n    type: 'symbol',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {field: 'offset', mult: 0.5},\n        y: {scale: 'legend', field: 'index'},\n        shape: {value: config.symbolShape},\n        size: {value: config.symbolSize},\n        stroke: {value: config.symbolColor},\n        strokeWidth: {value: config.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: 'offset', mult: 0.5},\n        y: {scale: 'legend', field: 'index'},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vLegendLabels(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {field: 'offset', offset: 5},\n        y: {scale: 'legend', field: 'index'},\n        fill: {value: config.labelColor},\n        font: {value: config.labelFont},\n        fontSize: {value: config.labelFontSize},\n        align: {value: config.labelAlign},\n        baseline: {value: config.labelBaseline},\n        text: {field: 'label'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: 'offset', offset: 5},\n        y: {scale: 'legend', field: 'index'},\n      }\n    }\n  };\n}\n\nfunction legendGradient(config) {\n  return {\n    type: 'rect',\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: config.gradientWidth},\n        height: {value: config.gradientHeight},\n        stroke: {value: config.gradientStrokeColor},\n        strokeWidth: {value: config.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction hLegendLabels(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {scale: 'legend', field: 'data'},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: config.labelColor},\n        font: {value: config.labelFont},\n        fontSize: {value: config.labelFontSize},\n        align: {field: 'align'},\n        baseline: {value: 'top'},\n        text: {field: 'label'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: 'legend', field: 'data'},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;",
    "module.exports = function visit(node, func) {\n  var i, n, s, m, items;\n  if (func(node)) return true;\n\n  var sets = ['items', 'axisItems', 'legendItems'];\n  for (s=0, m=sets.length; s<m; ++s) {\n    if ((items = node[sets[s]])) {\n      for (i=0, n=items.length; i<n; ++i) {\n        if (visit(items[i], func)) return true;\n      }\n    }\n  }\n};",
    "var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    Deps = df.Dependencies,\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    summarize: {\n      type: 'custom',\n      set: function(summarize) {\n        var signalDeps = {},\n            tx = this._transform,\n            i, len, f, fields, name, ops;\n\n        if (!dl.isArray(fields = summarize)) { // Object syntax from dl\n          fields = [];\n          for (name in summarize) {\n            ops = dl.array(summarize[name]);\n            fields.push({field: name, ops: ops});\n          }\n        }\n\n        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }\n\n        for (i=0, len=fields.length; i<len; ++i) {\n          f = fields[i];\n          if (f.field.signal) { signalDeps[f.field.signal] = 1; }\n          dl.array(f.ops).forEach(sg);\n          dl.array(f.as).forEach(sg);\n        }\n\n        tx._fields = fields;\n        tx._aggr = null;\n        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));\n        return tx;\n      }\n    }\n  });\n\n  this._aggr  = null; // dl.Aggregator\n  this._input = null; // Used by Facetor._on_keep.\n  this._args  = null; // To cull re-computation.\n  this._fields = [];\n  this._out = [];\n\n  this._type = TYPES.TUPLE;\n  this._acc = {groupby: dl.true, value: dl.true};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Aggregate.prototype = Object.create(Transform.prototype));\nprototype.constructor = Aggregate;\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1,\n  TUPLE: 2,\n  MULTI: 3\n};\n\nAggregate.VALID_OPS = [\n  'values', 'count', 'valid', 'missing', 'distinct',\n  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\n  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\n  'argmin', 'argmax'\n];\n\nprototype.type = function(type) {\n  return (this._type = type, this);\n};\n\nprototype.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nprototype.aggr = function() {\n  if (this._aggr) return this._aggr;\n\n  var g = this._graph,\n      hasGetter = false,\n      args = [],\n      groupby = this.param('groupby').field,\n      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };\n\n  // Prepare summarize fields.\n  var fields = this._fields.map(function(f) {\n    var field = {\n      name: value(f.field),\n      as:   dl.array(f.as),\n      ops:  dl.array(value(f.ops)).map(value),\n      get:  f.get\n    };\n    hasGetter = hasGetter || field.get != null;\n    args.push(field.name);\n    return field;\n  });\n\n  // If there is an arbitrary getter, all bets are off.\n  // Otherwise, we can check argument fields to cull re-computation.\n  groupby.forEach(function(g) {\n    if (g.get) hasGetter = true;\n    args.push(g.name || g);\n  });\n  this._args = hasGetter || !fields.length ? null : args;\n\n  if (!fields.length) fields = {'*': 'values'};\n\n  // Instatiate our aggregator instance.\n  // Facetor is a special subclass that can facet into data pipelines.\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  // Collect output fields sets by this aggregate.\n  this._out = getFields(aggr);\n\n  // If we are processing tuples, key them by '_id'.\n  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }\n\n  return aggr;\n};\n\nfunction getFields(aggr) {\n  // Collect the output fields set by this aggregate.\n  var f = [], i, n, j, m, dims, vals, meas;\n\n  dims = aggr._dims;\n  for (i=0, n=dims.length; i<n; ++i) {\n    f.push(dims[i].name);\n  }\n\n  vals = aggr._aggr;\n  for (i=0, n=vals.length; i<n; ++i) {\n    meas = vals[i].measures.fields;\n    for (j=0, m=meas.length; j<m; ++j) {\n      f.push(meas[j]);\n    }\n  }\n\n  return f;\n}\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['aggregate']);\n\n  var output = ChangeSet.create(input),\n      aggr = this.aggr(),\n      out = this._out,\n      args = this._args,\n      reeval = true,\n      p = Tuple.prev,\n      add, rem, mod, mark, i;\n\n  // Upon reset, retract prior tuples and re-initialize.\n  if (reset) {\n    output.rem.push.apply(output.rem, aggr.result());\n    aggr.clear();\n    this._aggr = null;\n    aggr = this.aggr();\n  }\n\n  // Get update methods according to input type.\n  if (this._type === TYPES.TUPLE) {\n    add  = function(x) { aggr._add(x); Tuple.prev_init(x); };\n    rem  = function(x) { aggr._rem(p(x)); };\n    mod  = function(x) { aggr._mod(x, p(x)); };\n    mark = function(x) { aggr._markMod(x, p(x)); };\n  } else {\n    var gby = this._acc.groupby,\n        val = this._acc.value,\n        get = this._type === TYPES.VALUE ? val : function(x) {\n          return { _id: x._id, groupby: gby(x), value: val(x) };\n        };\n    add  = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };\n    rem  = function(x) { aggr._rem(get(p(x))); };\n    mod  = function(x) { aggr._mod(get(x), get(p(x))); };\n    mark = function(x) { aggr._mark(get(x), get(p(x))); };\n  }\n\n  input.add.forEach(add);\n  if (reset) {\n    // A signal change triggered reflow. Add everything.\n    // No need for rem, we cleared the aggregator.\n    input.mod.forEach(add);\n  } else {\n    input.rem.forEach(rem);\n\n    // If possible, check argument fields to see if we need to re-process mods.\n    if (args) for (i=0, reeval=false; i<args.length; ++i) {\n      if (input.fields[args[i]]) { reeval = true; break; }\n    }\n    input.mod.forEach(reeval ? mod : mark);\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  for (i=0; i<out.length; ++i) {\n    output.fields[out[i]] = 1;\n  }\n  return (aggr._input = input, aggr.changes(output));\n};\n\nmodule.exports = Aggregate;",
    "var Base = require('./Transform').prototype;\n\nfunction BatchTransform() {\n  // Nearest appropriate collector.\n  // Set by the dataflow Graph during connection.\n  this._collector = null;\n}\n\nvar prototype = (BatchTransform.prototype = Object.create(Base));\nprototype.constructor = BatchTransform;\n\nprototype.init = function(graph) {\n  Base.init.call(this, graph);\n  return this.batch(true);\n};\n\nprototype.transform = function(input, reset) {\n  return this.batchTransform(input, this._collector.data(), reset);\n};\n\nprototype.batchTransform = function(/* input, data, reset */) {\n};\n\nmodule.exports = BatchTransform;",
    "var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Bin(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: 'field'},\n    min: {type: 'value'},\n    max: {type: 'value'},\n    base: {type: 'value', default: 10},\n    maxbins: {type: 'value', default: 20},\n    step: {type: 'value'},\n    steps: {type: 'value'},\n    minstep: {type: 'value'},\n    div: {type: 'array<value>', default: [5, 2]}\n  });\n\n  this._output = {\n    start: 'bin_start',\n    end:   'bin_end',\n    mid:   'bin_mid'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Bin.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Bin;\n\nprototype.extent = function(data) {\n  // TODO only recompute extent upon data or field change?\n  var e = [this.param('min'), this.param('max')], d;\n  if (e[0] == null || e[1] == null) {\n    d = dl.extent(data, this.param('field').accessor);\n    if (e[0] == null) e[0] = d[0];\n    if (e[1] == null) e[1] = d[1];\n  }\n  return e;\n};\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['binning']);\n\n  var extent  = this.extent(data),\n      output  = this._output,\n      step    = this.param('step'),\n      steps   = this.param('steps'),\n      minstep = this.param('minstep'),\n      get     = this.param('field').accessor,\n      opt = {\n        min: extent[0],\n        max: extent[1],\n        base: this.param('base'),\n        maxbins: this.param('maxbins'),\n        div: this.param('div')\n      };\n\n  if (step) opt.step = step;\n  if (steps) opt.steps = steps;\n  if (minstep) opt.minstep = minstep;\n  var b = dl.bins(opt),\n      s = b.step;\n\n  function update(d) {\n    var v = get(d);\n    v = v == null ? null\n      : b.start + s * ~~((v - b.start) / s);\n    Tuple.set(d, output.start, v);\n    Tuple.set(d, output.end, v + s);\n    Tuple.set(d, output.mid, v + s/2);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Bin;",
    "var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction CountPattern(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field:     {type: 'field', default: 'data'},\n    pattern:   {type: 'value', default: '[\\\\w\\']+'},\n    case:      {type: 'value', default: 'lower'},\n    stopwords: {type: 'value', default: ''}\n  });\n\n  this._output = {text: 'text', count: 'count'};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (CountPattern.prototype = Object.create(Transform.prototype));\nprototype.constructor = CountPattern;\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['countpattern']);\n\n  var get = this.param('field').accessor,\n      pattern = this.param('pattern'),\n      stop = this.param('stopwords'),\n      rem = false;\n\n  // update parameters\n  if (this._stop !== stop) {\n    this._stop = stop;\n    this._stop_re = new RegExp('^' + stop + '$', 'i');\n    reset = true;\n  }\n\n  if (this._pattern !== pattern) {\n    this._pattern = pattern;\n    this._match = new RegExp(this._pattern, 'g');\n    reset = true;\n  }\n\n  if (reset) this._counts = {};\n\n  function curr(t) { return (Tuple.prev_init(t), get(t)); }\n  function prev(t) { return get(Tuple.prev(t)); }\n\n  this._add(input.add, curr);\n  if (!reset) this._rem(input.rem, prev);\n  if (reset || (rem = input.fields[get.field])) {\n    if (rem) this._rem(input.mod, prev);\n    this._add(input.mod, curr);\n  }\n\n  // generate output tuples\n  return this._changeset(input);\n};\n\nprototype._changeset = function(input) {\n  var counts = this._counts,\n      tuples = this._tuples || (this._tuples = {}),\n      change = df.ChangeSet.create(input),\n      out = this._output, w, t, c;\n\n  for (w in counts) {\n    t = tuples[w];\n    c = counts[w] || 0;\n    if (!t && c) {\n      tuples[w] = (t = Tuple.ingest({}));\n      t[out.text] = w;\n      t[out.count] = c;\n      change.add.push(t);\n    } else if (c === 0) {\n      if (t) change.rem.push(t);\n      delete counts[w];\n      delete tuples[w];\n    } else if (t[out.count] !== c) {\n      Tuple.set(t, out.count, c);\n      change.mod.push(t);\n    }\n  }\n  return change;\n};\n\nprototype._tokenize = function(text) {\n  switch (this.param('case')) {\n    case 'upper': text = text.toUpperCase(); break;\n    case 'lower': text = text.toLowerCase(); break;\n  }\n  return text.match(this._match);\n};\n\nprototype._add = function(tuples, get) {\n  var counts = this._counts,\n      stop = this._stop_re,\n      tok, i, j, t;\n\n  for (j=0; j<tuples.length; ++j) {\n    tok = this._tokenize(get(tuples[j]));\n    for (i=0; i<tok.length; ++i) {\n      if (!stop.test(t=tok[i])) {\n        counts[t] = 1 + (counts[t] || 0);\n      }\n    }\n  }\n};\n\nprototype._rem = function(tuples, get) {\n  var counts = this._counts,\n      stop = this._stop_re,\n      tok, i, j, t;\n\n  for (j=0; j<tuples.length; ++j) {\n    tok = this._tokenize(get(tuples[j]));\n    for (i=0; i<tok.length; ++i) {\n      if (!stop.test(t=tok[i])) {\n        counts[t] -= 1;\n      }\n    }\n  }\n};\n\nmodule.exports = CountPattern;",
    "var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    SIGNALS = df.Dependencies.SIGNALS,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Cross(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: 'data'},\n    diagonal: {type: 'value', default: 'true'},\n    filter: {type: 'expr'}\n  });\n\n  this._output = {'left': 'a', 'right': 'b'};\n  this._lastWith = null; // Last time we crossed w/with-ds.\n  this._cids  = {};\n  this._cache = {}; \n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Cross.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Cross;\n\n// Each cached incoming tuple also has a flag to determine whether \n// any tuples were filtered.\nfunction _cache(x, t) {\n  var c = this._cache,\n      cross = c[x._id] || (c[x._id] = {c: [], f: false});\n  cross.c.push(t);\n}\n\nfunction _cid(left, x, y) {\n  return left ? x._id+'_'+y._id : y._id+'_'+x._id;\n}\n\nfunction add(output, left, data, diag, test, mids, x) {\n  var as = this._output,\n      cache = this._cache,\n      cids  = this._cids,\n      oadd  = output.add, \n      fltrd = false,\n      i = 0, len = data.length,\n      t = {}, y, cid;\n\n  for (; i<len; ++i) {\n    y = data[i];\n    cid = _cid(left, x, y);\n    if (cids[cid]) continue;\n    if (x._id === y._id && !diag) continue;\n\n    Tuple.set(t, as.left, left ? x : y);\n    Tuple.set(t, as.right, left ? y : x);\n\n    // Only ingest a tuple if we keep it around. Otherwise, flag the\n    // caches as filtered. \n    if (!test || test(t)) {\n      oadd.push(t=Tuple.ingest(t));\n      _cache.call(this, x, t);\n      if (x._id !== y._id) _cache.call(this, y, t);\n      mids[t._id] = 1;\n      cids[cid] = true;\n      t = {};\n    } else {\n      if (cache[y._id]) cache[y._id].f = true;\n      fltrd = true;\n    }\n  }\n\n  if (cache[x._id]) cache[x._id].f = fltrd;\n}\n\nfunction mod(output, left, data, diag, test, mids, rids, x) {\n  var as = this._output,\n      cache = this._cache,\n      cids  = this._cids,\n      cross = cache[x._id],\n      tpls  = cross && cross.c,\n      fltrd = !cross || cross.f,\n      omod  = output.mod,\n      orem  = output.rem,\n      i, t, y, l, cid;\n\n  // If we have cached values, iterate through them for lazy\n  // removal, and to re-run the filter. \n  if (tpls) {\n    for (i=tpls.length-1; i>=0; --i) {\n      t = tpls[i];\n      l = x === t[as.left]; // Cache has tpls w/x both on left & right.\n      y = l ? t[as.right] : t[as.left];\n      cid = _cid(l, x, y);\n\n      // Lazy removal: y was previously rem'd, so clean up the cache.\n      if (!cache[y._id]) {\n        cids[cid] = false;\n        tpls.splice(i, 1);\n        continue;\n      }\n\n      if (!test || test(t)) {\n        if (mids[t._id]) continue;\n        omod.push(t);\n        mids[t._id] = 1;\n      } else {\n        if (!rids[t._id]) orem.push.apply(orem, tpls.splice(i, 1));\n        rids[t._id] = 1;\n        cids[cid] = false;\n        cross.f = true;\n      }\n    }\n  }\n\n  // If we have a filter param, call add to catch any tuples that may\n  // have previously been filtered.\n  if (test && fltrd) add.call(this, output, left, data, diag, test, mids, x); \n}\n\nfunction rem(output, left, rids, x) {\n  var as = this._output,\n      cross = this._cache[x._id],\n      cids  = this._cids,\n      orem  = output.rem, \n      i, len, t, y, l;\n  if (!cross) return;\n\n  for (i=0, len=cross.c.length; i<len; ++i) {\n    t = cross.c[i];\n    l = x === t[as.left];\n    y = l ? t[as.right] : t[as.left];\n    cids[_cid(l, x, y)] = false;\n    if (!rids[t._id]) {\n      orem.push(t);\n      rids[t._id] = 1;\n    }\n  }\n\n  this._cache[x._id] = null;\n}\n\nfunction purge(output, rids) {\n  var cache = this._cache,\n      keys  = dl.keys(cache),\n      rem = output.rem,\n      i, len, j, jlen, cross, t;\n\n  for (i=0, len=keys.length; i<len; ++i) {\n    cross = cache[keys[i]];\n    for (j=0, jlen=cross.c.length; j<jlen; ++j) {\n      t = cross.c[j];\n      if (rids[t._id]) continue;\n      rem.push(t);\n      rids[t._id] = 1;\n    }\n  }\n\n  this._cache = {};\n  this._cids = {};\n  this._lastWith = null;\n}\n\nprototype.batchTransform = function(input, data, reset) {\n  log.debug(input, ['crossing']);\n\n  var g = this._graph,\n      w = this.param('with'),\n      f = this.param('filter'),\n      diag = this.param('diagonal'),\n      as = this._output,\n      sg = g.values(SIGNALS, this.dependency(SIGNALS)),\n      test = f ? function(x) {return f(x, null, sg); } : null,\n      selfCross = (!w.name),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = ChangeSet.create(input),\n      mids = {}, rids = {}; // Track IDs to prevent dupe mod/rem tuples.\n\n  // If signal values (for diag or test) have changed, purge the cache\n  // and re-run cross in batch mode. Otherwise stream cross values.\n  if (reset) {\n    purge.call(this, output, rids);\n    data.forEach(add.bind(this, output, true, wdata, diag, test, mids));\n    this._lastWith = woutput.stamp;\n  } else {\n    input.rem.forEach(rem.bind(this, output, true, rids));\n    input.add.forEach(add.bind(this, output, true, wdata, diag, test, mids));\n\n    if (woutput.stamp > this._lastWith) {\n      woutput.rem.forEach(rem.bind(this, output, false, rids));\n      woutput.add.forEach(add.bind(this, output, false, data, diag, test, mids));\n      woutput.mod.forEach(mod.bind(this, output, false, data, diag, test, mids, rids));\n      this._lastWith = woutput.stamp;\n    }\n\n    // Mods need to come after all removals have been run.\n    input.mod.forEach(mod.bind(this, output, true, wdata, diag, test, mids, rids));\n  }\n\n  output.fields[as.left]  = 1;\n  output.fields[as.right] = 1;\n  return output;\n};\n\nmodule.exports = Cross;",
    "var Transform = require('./Transform'),\n    Aggregate = require('./Aggregate');\n\nfunction Facet(graph) {\n  Transform.addParameters(this, {\n    transform: {\n      type: \"custom\",\n      set: function(pipeline) {\n        return (this._transform._pipeline = pipeline, this._transform);\n      },\n      get: function() {\n        var parse = require('../parse/transforms'),\n            facet = this._transform;\n        return facet._pipeline.map(function(t) {\n          return parse(facet._graph, t);\n        });\n      }\n    }\n  });\n\n  this._pipeline = [];\n  return Aggregate.call(this, graph);\n}\n\nvar prototype = (Facet.prototype = Object.create(Aggregate.prototype));\nprototype.constructor = Facet;\n\nprototype.aggr = function() {\n  return Aggregate.prototype.aggr.call(this).facet(this);\n};\n\nprototype.transform = function(input, reset) {\n  var output  = Aggregate.prototype.transform.call(this, input, reset);\n\n  // New facet cells should trigger a re-ranking of the dataflow graph.\n  // This ensures facet datasources are computed before scenegraph nodes.\n  // We rerank the Facet's first listener, which is the next node in the\n  // datasource's pipeline.\n  if (input.add.length) {\n    this.listeners()[0].rerank();\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;",
    "var dl = require('datalib'),\n    Aggregator = dl.Aggregator,\n    Base = Aggregator.prototype,\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    facetID = 0;\n\nfunction Facetor() {\n  Aggregator.call(this);\n  this._facet = null;\n  this._facetID = ++facetID;\n}\n\nvar prototype = (Facetor.prototype = Object.create(Base));\nprototype.constructor = Facetor;\n\nprototype.facet = function(f) {\n  return arguments.length ? (this._facet = f, this) : this._facet;\n};\n\nprototype._ingest = function(t) {\n  return Tuple.ingest(t, null);\n};\n\nprototype._assign = Tuple.set;\n\nfunction disconnect_cell(facet) {\n  log.debug({}, ['disconnecting cell', this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nprototype._newcell = function(x, key) {\n  var cell  = Base._newcell.call(this, x, key),\n      facet = this._facet;\n\n  if (facet) {\n    var graph = facet._graph,\n        tuple = cell.tuple,\n        pipeline = facet.param('transform');\n    cell.ds = graph.data(tuple._facetID, pipeline, tuple);\n    cell.disconnect = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nprototype._newtuple = function(x, key) {\n  var t = Base._newtuple.call(this, x);\n  if (this._facet) {\n    Tuple.set(t, 'key', key);\n    Tuple.set(t, '_facetID', this._facetID + '_' + key);\n  }\n  return t;\n};\n\nprototype.clear = function() {\n  if (this._facet) {\n    for (var k in this._cells) {\n      this._cells[k].disconnect(this._facet);\n    }\n  }\n  return Base.clear.call(this);\n};\n\nprototype._on_add = function(x, cell) {\n  if (this._facet) cell.ds._input.add.push(x);\n};\n\nprototype._on_rem = function(x, cell) {\n  if (this._facet) cell.ds._input.rem.push(x);\n};\n\nprototype._on_mod = function(x, prev, cell0, cell1) {\n  if (this._facet) { // Propagate tuples\n    if (cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nprototype._on_drop = function(cell) {\n  if (this._facet) cell.disconnect(this._facet);\n};\n\nprototype._on_keep = function(cell) {\n  // propagate sort, signals, fields, etc.\n  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);\n};\n\nmodule.exports = Facetor;",
    "var df = require('vega-dataflow'),\n    SIGNALS = df.Dependencies.SIGNALS,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: 'expr'}});\n\n  this._skip = {};\n  return this.router(true);\n}\n\nvar prototype = (Filter.prototype = Object.create(Transform.prototype));\nprototype.constructor = Filter;\n\nprototype.transform = function(input) {\n  log.debug(input, ['filtering']);\n\n  var output = df.ChangeSet.create(input),\n      graph = this._graph,\n      skip = this._skip,\n      test = this.param('test'),\n      signals = graph.values(SIGNALS, this.dependency(SIGNALS));\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test(x, null, signals)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test(x, null, signals),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;",
    "var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: 'array<field>'}\n  });\n\n  this._output = {key: 'key', value: 'value'};\n  this._cache = {};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Fold.prototype = Object.create(Transform.prototype));\nprototype.constructor = Fold;\n\nprototype._reset = function(input, output) {\n  for (var id in this._cache) {\n    output.rem.push.apply(output.rem, this._cache[id]);\n  }\n  this._cache = {};\n};\n\nprototype._tuple = function(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] ? Tuple.rederive(x, list[i]) : (list[i] = Tuple.derive(x));\n};\n\nprototype._fn = function(data, on, out) {\n  var i, j, n, m, d, t;\n  for (i=0, n=data.length; i<n; ++i) {\n    d = data[i];\n    for (j=0, m=on.field.length; j<m; ++j) {\n      t = this._tuple(d, j, m);\n      Tuple.set(t, this._output.key, on.field[j]);\n      Tuple.set(t, this._output.value, on.accessor[j](d));\n      out.push(t);\n    }\n  }\n};\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['folding']);\n\n  var fold = this,\n      on = this.param('fields'),\n      output = df.ChangeSet.create(input);\n\n  if (reset) this._reset(input, output);\n\n  this._fn(input.add, on, output.add);\n  this._fn(input.mod, on, reset ? output.add : output.mod);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if (input.add.length || input.rem.length ||\n      on.field.some(function(f) { return !!input.fields[f]; })) {\n    output.fields[this._output.key] = 1;\n    output.fields[this._output.value] = 1;\n  }\n  return output;\n};\n\nmodule.exports = Fold;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    ChangeSet = df.ChangeSet,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  this._prev = null;\n  this._interactive = false;\n  this._setup = true;\n  this._nodes  = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  Transform.addParameters(this, {\n    size: {type: 'array<value>', default: require('./screen').size},\n    bound: {type: 'value', default: true},\n    links: {type: 'data'},\n\n    // TODO: for now force these to be value params only (pun-intended)\n    // Can update to include fields after Parameter refactoring.\n    linkStrength: {type: 'value', default: 1},\n    linkDistance: {type: 'value', default: 20},\n    charge: {type: 'value', default: -30},\n\n    chargeDistance: {type: 'value', default: Infinity},\n    friction: {type: 'value', default: 0.9},\n    theta: {type: 'value', default: 0.8},\n    gravity: {type: 'value', default: 0.1},\n    alpha: {type: 'value', default: 0.1},\n    iterations: {type: 'value', default: 500},\n\n    interactive: {type: 'value', default: this._interactive},\n    active: {type: 'value', default: this._prev},\n    fixed: {type: 'data'}\n  });\n\n  this._output = {\n    'x': 'layout_x',\n    'y': 'layout_y'\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Force.prototype = Object.create(Transform.prototype));\nprototype.constructor = Force;\n\nprototype.transform = function(nodeInput, reset) {\n  log.debug(nodeInput, ['force']);\n  reset = reset - (nodeInput.signals.active ? 1 : 0);\n\n  // get variables\n  var interactive = this.param('interactive'),\n      linkSource = this.param('links').source,\n      linkInput = linkSource.last(),\n      active = this.param('active'),\n      output = this._output,\n      layout = this._layout,\n      nodes = this._nodes,\n      links = this._links;\n\n  // configure nodes, links and layout\n  if (linkInput.stamp < nodeInput.stamp) linkInput = null;\n  this.configure(nodeInput, linkInput, interactive, reset);\n\n  // run batch layout\n  if (!interactive) {\n    var iterations = this.param('iterations');\n    for (var i=0; i<iterations; ++i) layout.tick();\n    layout.stop();\n  }\n\n  // update node positions\n  this.update(active);\n\n  // re-up alpha on parameter change\n  if (reset || active !== this._prev && active && active.update) {\n    layout.alpha(this.param('alpha')); // re-start layout\n  }\n\n  // update active node status,\n  if (active !== this._prev) {\n    this._prev = active;\n  }\n\n  // process removed nodes or edges\n  if (nodeInput.rem.length) {\n    layout.nodes(this._nodes = Tuple.idFilter(nodes, nodeInput.rem));\n  }\n  if (linkInput && linkInput.rem.length) {\n    layout.links(this._links = Tuple.idFilter(links, linkInput.rem));\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nprototype.configure = function(nodeInput, linkInput, interactive, reset) {\n  // check if we need to run configuration\n  var layout = this._layout,\n      update = this._setup || nodeInput.add.length ||\n            linkInput && linkInput.add.length ||\n            interactive !== this._interactive ||\n            this.param('charge') !== layout.charge() ||\n            this.param('linkStrength') !== layout.linkStrength() ||\n            this.param('linkDistance') !== layout.linkDistance();\n\n  if (update || reset) {\n    // a parameter changed, so update tick-only parameters\n    layout\n      .size(this.param('size'))\n      .chargeDistance(this.param('chargeDistance'))\n      .theta(this.param('theta'))\n      .gravity(this.param('gravity'))\n      .friction(this.param('friction'));\n  }\n\n  if (!update) return; // if no more updates needed, return now\n\n  this._setup = false;\n  this._interactive = interactive;\n\n  var force = this,\n      graph = this._graph,\n      nodes = this._nodes,\n      links = this._links, a, i;\n\n  // process added nodes\n  for (a=nodeInput.add, i=0; i<a.length; ++i) {\n    nodes.push({tuple: a[i]});\n  }\n\n  // process added edges\n  if (linkInput) for (a=linkInput.add, i=0; i<a.length; ++i) {\n    // TODO add configurable source/target accessors\n    // TODO support lookup by node id\n    // TODO process 'mod' of edge source or target?\n    links.push({\n      tuple:  a[i],\n      source: nodes[a[i].source],\n      target: nodes[a[i].target]\n    });\n  }\n\n  // setup handler for force layout tick events\n  var tickHandler = !interactive ? null : function() {\n    // re-schedule the transform, force reflow\n    graph.propagate(ChangeSet.create(null, true), force);\n  };\n\n  // configure the rest of the layout\n  layout\n    .linkStrength(this.param('linkStrength'))\n    .linkDistance(this.param('linkDistance'))\n    .charge(this.param('charge'))\n    .nodes(nodes)\n    .links(links)\n    .on('tick', tickHandler)\n    .start().alpha(this.param('alpha'));\n};\n\nprototype.update = function(active) {\n  var output = this._output,\n      bound = this.param('bound'),\n      fixed = this.param('fixed'),\n      size = this.param('size'),\n      nodes = this._nodes,\n      lut = {}, id, i, n, t, x, y;\n\n  if (fixed && fixed.source) {\n    // TODO: could cache and update as needed?\n    fixed = fixed.source.values();\n    for (i=0, n=fixed.length; i<n; ++i) {\n      lut[fixed[i].id] = 1;\n    }\n  }\n\n  for (i=0; i<nodes.length; ++i) {\n    n = nodes[i];\n    t = n.tuple;\n    id = t._id;\n\n    if (active && active.id === id) {\n      n.fixed = 1;\n      if (active.update) {\n        n.x = n.px = active.x;\n        n.y = n.py = active.y;\n      }\n    } else {\n      n.fixed = lut[id] || 0;\n    }\n\n    x = bound ? Math.max(0, Math.min(n.x, size[0])) : n.x;\n    y = bound ? Math.max(0, Math.min(n.y, size[1])) : n.y;\n    Tuple.set(t, output.x, x);\n    Tuple.set(t, output.y, y);\n  }\n};\n\nmodule.exports = Force;",
    "var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    SIGNALS = df.Dependencies.SIGNALS,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: 'value'},\n    expr:  {type: 'expr'}\n  });\n\n  return this.mutates(true);\n}\n\nvar prototype = (Formula.prototype = Object.create(Transform.prototype));\nprototype.constructor = Formula;\n\nprototype.transform = function(input) {\n  log.debug(input, ['formulating']);\n\n  var g = this._graph,\n      field = this.param('field'),\n      expr = this.param('expr'),\n      signals = g.values(SIGNALS, this.dependency(SIGNALS));\n\n  function set(x) {\n    Tuple.set(x, field, expr(x, null, signals));\n  }\n\n  input.add.forEach(set);\n\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: 'field'},\n    lat: {type: 'field'}\n  });\n\n  this._output = {\n    'x': 'layout_x',\n    'y': 'layout_y'\n  };\n  return this.mutates(true);\n}\n\nGeo.Parameters = {\n  projection: {type: 'value', default: 'mercator'},\n  center:     {type: 'array<value>'},\n  translate:  {type: 'array<value>', default: require('./screen').center},\n  rotate:     {type: 'array<value>'},\n  scale:      {type: 'value'},\n  precision:  {type: 'value'},\n  clipAngle:  {type: 'value'},\n  clipExtent: {type: 'value'}\n};\n\nGeo.d3Projection = function() {\n  var p = this.param('projection'),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === 'projection' || !proj[name]) continue;\n    value = this.param(name);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar prototype = (Geo.prototype = Object.create(Transform.prototype));\nprototype.constructor = Geo;\n\nprototype.transform = function(input) {\n  log.debug(input, ['geo']);\n\n  var output = this._output,\n      lon = this.param('lon').accessor,\n      lat = this.param('lat').accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll) || [null, null];\n    Tuple.set(t, output.x, xy[0]);\n    Tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Geo = require('./Geo'),\n    Transform = require('./Transform');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    field: {type: 'field', default: null},\n  });\n\n  this._output = {\n    'path': 'layout_path'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (GeoPath.prototype = Object.create(Transform.prototype));\nprototype.constructor = GeoPath;\n\nprototype.transform = function(input) {\n  log.debug(input, ['geopath']);\n\n  var output = this._output,\n      geojson = this.param('field').accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    Tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Hierarchy(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: 'array<field>', default: null},\n    children: {type: 'field', default: 'children'},\n    parent: {type: 'field', default: 'parent'},\n    field: {type: 'value', default: null},\n    // layout parameters\n    mode: {type: 'value', default: 'tidy'}, // tidy, cluster, partition\n    size: {type: 'array<value>', default: require('./screen').size},\n    nodesize: {type: 'array<value>', default: null},\n    orient: {type: 'value', default: 'cartesian'}\n  });\n\n  this._mode = null;\n  this._output = {\n    'x':      'layout_x',\n    'y':      'layout_y',\n    'width':  'layout_width',\n    'height': 'layout_height',\n    'depth':  'layout_depth'\n  };\n  return this.mutates(true);\n}\n\nvar PARTITION = 'partition';\n\nvar SEPARATION = {\n  cartesian: function(a, b) { return (a.parent === b.parent ? 1 : 2); },\n  radial: function(a, b) { return (a.parent === b.parent ? 1 : 2) / a.depth; }\n};\n\nvar prototype = (Hierarchy.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Hierarchy;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['hierarchy layout']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      mode   = this.param('mode'),\n      sort   = this.param('sort'),\n      nodesz = this.param('nodesize'),\n      parent = this.param('parent').accessor,\n      root = data.filter(function(d) { return parent(d) === null; })[0];\n\n  if (mode !== this._mode) {\n    this._mode = mode;\n    if (mode === 'tidy') mode = 'tree';\n    layout = (this._layout = d3.layout[mode]());\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.depth] = 1;\n  if (mode === PARTITION) {\n    input.fields[output.width] = 1;\n    input.fields[output.height] = 1;\n    layout.value(this.param('field').accessor);\n  } else {\n    layout.separation(SEPARATION[this.param('orient')]);\n  }\n\n  if (nodesz.length && mode !== PARTITION) {\n    layout.nodeSize(nodesz);\n  } else {\n    layout.size(this.param('size'));\n  }\n\n  layout\n    .sort(sort.field.length ? dl.comparator(sort.field) : null)\n    .children(this.param('children').accessor)\n    .nodes(root);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    Tuple.set(n, output.x, n.x);\n    Tuple.set(n, output.y, n.y);\n    Tuple.set(n, output.depth, n.depth);\n    if (mode === PARTITION) {\n      Tuple.set(n, output.width, n.dx);\n      Tuple.set(n, output.height, n.dy);\n    }\n  });\n\n  // return changeset\n  return input;\n};\n\nmodule.exports = Hierarchy;",
    "var dl = require('datalib'),\n    log = require('vega-logging'),\n    Tuple = require('vega-dataflow').Tuple,\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Impute(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    orderby: {type: 'array<field>'},\n    field:   {type: 'field'},\n    method:  {type: 'value', default: 'value'},\n    value:   {type: 'value', default: 0}\n  });\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Impute.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Impute;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['imputing']);\n\n  var groupby = this.param('groupby'),\n      orderby = this.param('orderby'),\n      method = this.param('method'),\n      value = this.param('value'),\n      field = this.param('field'),\n      get = field.accessor,\n      name = field.field,\n      prev = this._imputed || [], curr = [],\n      groups = partition(data, groupby.accessor, orderby.accessor),\n      domain = groups.domain,\n      group, i, j, n, m, t;\n\n  function getval(x) {\n    return x == null ? null : get(x);\n  }\n\n  for (j=0, m=groups.length; j<m; ++j) {\n    group = groups[j];\n\n    // determine imputation value\n    if (method !== 'value') {\n      value = dl[method](group, getval);\n    }\n\n    // add tuples for missing values\n    for (i=0, n=group.length; i<n; ++i) {\n      if (group[i] == null) {\n        t = tuple(groupby.field, group.values, orderby.field, domain[i]);\n        t[name] = value;\n        curr.push(t);\n      }\n    }\n  }\n\n  // update changeset with imputed tuples\n  for (i=0, n=curr.length; i<n; ++i) {\n    input.add.push(curr[i]);\n  }\n  for (i=0, n=prev.length; i<n; ++i) {\n    input.rem.push(prev[i]);\n  }\n  this._imputed = curr;\n\n  return input;\n};\n\nfunction tuple(gb, gv, ob, ov) {\n  var t = {_imputed: true}, i;\n  for (i=0; i<gv.length; ++i) t[gb[i]] = gv[i];\n  for (i=0; i<ov.length; ++i) t[ob[i]] = ov[i];\n  return Tuple.ingest(t);\n}\n\nfunction partition(data, groupby, orderby) {\n  var groups = [],\n      get = function(f) { return f(x); },\n      val = function(d) { return (x=d, orderby.map(get)); },\n      map, i, x, k, g, domain, lut, N;\n\n  domain = groups.domain = dl.unique(data, val);\n  N = domain.length;\n  lut = domain.reduce(function(m, d, i) {\n    return (m[d] = {value:d, index:i}, m);\n  }, {});\n\n  // partition data points into groups\n  for (map={}, i=0; i<data.length; ++i) {\n    x = data[i];\n    k = groupby == null ? [] : groupby.map(get);\n    g = map[k] || (groups.push(map[k] = Array(N)), map[k].values = k, map[k]);\n    g[lut[val(x)].index] = x;\n  }\n\n  return groups;\n}\n\nmodule.exports = Impute;",
    "var Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    sourceX:  {type: 'field', default: '_source.layout_x'},\n    sourceY:  {type: 'field', default: '_source.layout_y'},\n    targetX:  {type: 'field', default: '_target.layout_x'},\n    targetY:  {type: 'field', default: '_target.layout_y'},\n    tension:  {type: 'value', default: 0.2},\n    shape:    {type: 'value', default: 'line'}\n  });\n\n  this._output = {'path': 'layout_path'};\n  return this.mutates(true);\n}\n\nvar prototype = (LinkPath.prototype = Object.create(Transform.prototype));\nprototype.constructor = LinkPath;\n\nfunction line(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'L' + tx + ',' + ty;\n}\n\nfunction curve(sx, sy, tx, ty, tension) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return 'M' + sx + ',' + sy +\n         'C' + (sx+ix) + ',' + (sy+iy) +\n         ' ' + (tx+iy) + ',' + (ty-ix) +\n         ' ' + tx + ',' + ty;\n}\n\nfunction cornerX(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'V' + ty + 'H' + tx;\n}\n\nfunction cornerY(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'H' + tx + 'V' + ty;\n}\n\nfunction cornerR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +\n         ' ' + (sr*tc) + ',' + (sr*ts) +\n         'L' + (tr*tc) + ',' + (tr*ts);\n}\n\nfunction diagonalX(sx, sy, tx, ty) {\n  var m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + m  + ',' + sy +\n         ' ' + m  + ',' + ty +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalY(sx, sy, tx, ty) {\n  var m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + sx + ',' + m +\n         ' ' + tx + ',' + m +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      mr = (sr + tr) / 2;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'C' + (mr*sc) + ',' + (mr*ss) +\n         ' ' + (mr*tc) + ',' + (mr*ts) +\n         ' ' + (tr*tc) + ',' + (tr*ts);\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  cornerX:   cornerX,\n  cornerY:   cornerY,\n  cornerR:   cornerR,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY,\n  diagonalR: diagonalR\n};\n\nprototype.transform = function(input) {\n  log.debug(input, ['linkpath']);\n\n  var output = this._output,\n      shape = shapes[this.param('shape')] || shapes.line,\n      sourceX = this.param('sourceX').accessor,\n      sourceY = this.param('sourceY').accessor,\n      targetX = this.param('targetX').accessor,\n      targetY = this.param('targetY').accessor,\n      tension = this.param('tension');\n\n  function set(t) {\n    var path = shape(sourceX(t), sourceY(t), targetX(t), targetY(t), tension);\n    Tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;",
    "var Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Lookup(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    on:      {type: 'data'},\n    onKey:   {type: 'field', default: null},\n    as:      {type: 'array<value>'},\n    keys:    {type: 'array<field>', default: ['data']},\n    default: {type: 'value'}\n  });\n\n  return this.mutates(true);\n}\n\nvar prototype = (Lookup.prototype = Object.create(Transform.prototype));\nprototype.constructor = Lookup;\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['lookup']);\n\n  var on = this.param('on'),\n      onLast = on.source.last(),\n      onData = on.source.values(),\n      onKey = this.param('onKey'),\n      onF = onKey.field,\n      keys = this.param('keys'),\n      get = keys.accessor,\n      as = this.param('as'),\n      defaultValue = this.param('default'),\n      lut = this._lut,\n      i, v;\n\n  // build lookup table on init, withKey modified, or tuple add/rem\n  if (lut == null || this._on !== onF || onF && onLast.fields[onF] ||\n      onLast.add.length || onLast.rem.length)\n  {\n    if (onF) { // build hash from withKey field\n      onKey = onKey.accessor;\n      for (lut={}, i=0; i<onData.length; ++i) {\n        lut[onKey(v = onData[i])] = v;\n      }\n    } else { // otherwise, use index-based lookup\n      lut = onData;\n    }\n    this._lut = lut;\n    this._on = onF;\n    reset = true;\n  }\n\n  function set(t) {\n    for (var i=0; i<get.length; ++i) {\n      var v = lut[get[i](t)] || defaultValue;\n      Tuple.set(t, as[i], v);\n    }\n  }\n\n  input.add.forEach(set);\n  var run = keys.field.some(function(f) { return input.fields[f]; });\n  if (run || reset) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  as.forEach(function(k) { input.fields[k] = 1; });\n  return input;\n};\n\nmodule.exports = Lookup;",
    "var dl = require('datalib'),\n    Deps = require('vega-dataflow').Dependencies,\n    expr = require('../parse/expr');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i,\n    valType   = /value/i;\n\nfunction Parameter(name, type, transform) {\n  this._name = name;\n  this._type = type;\n  this._transform = transform;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = [];\n}\n\nvar prototype = Parameter.prototype;\n\nfunction get() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  var val = isArray ? this._value : this._value[0],\n      acc = isArray ? this._accessors : this._accessors[0];\n\n  if (!dl.isValid(acc) && valType.test(this._type)) {\n    return val;\n  } else {\n    return isData ? { name: val, source: acc } :\n    isField ? { field: val, accessor: acc } : val;\n  }\n}\n\nprototype.get = function() {\n  var graph = this._transform._graph,\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      i, n, sig, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return get.call(this);\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return get.call(this); // TODO: support signal as dataTypes\n  }\n\n  for (i=0, n=this._signals.length; i<n; ++i) {\n    sig = this._signals[i];\n    idx = sig.index;\n    val = sig.value(graph);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ?\n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return get.call(this);\n};\n\nprototype.set = function(value) {\n  var p = this,\n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  p._signals = [];\n  this._value = dl.array(value).map(function(v, i) {\n    var e;\n    if (dl.isString(v)) {\n      if (isExpr) {\n        e = expr(v);\n        p._transform.dependency(Deps.FIELDS,  e.fields);\n        p._transform.dependency(Deps.SIGNALS, e.globals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        p._accessors[i] = dl.accessor(v);\n        p._transform.dependency(Deps.FIELDS, dl.field(v));\n      } else if (isData) {\n        p._resolution = true;\n        p._transform.dependency(Deps.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      p._accessors[i] = dl.accessor(v.field);\n      p._transform.dependency(Deps.FIELDS, dl.field(v.field));\n      return v.field;\n    } else if (v.signal !== undefined) {\n      p._resolution = true;\n      p._transform.dependency(Deps.SIGNALS, v.signal);\n      p._signals.push({\n        index: i,\n        value: function(graph) { return graph.signalRef(v.signal); }\n      });\n      return v.signal;\n    } else if (v.expr !== undefined) {\n      p._resolution = true;\n      e = expr(v.expr);\n      p._transform.dependency(Deps.SIGNALS, e.globals);\n      p._signals.push({\n        index: i,\n        value: function(graph) {\n          return e.fn(null, null, graph.values(Deps.SIGNALS, e.globals));\n        }\n      });\n      return v.expr;\n    }\n\n    return v;\n  });\n\n  return p._transform;\n};\n\nmodule.exports = Parameter;",
    "var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field:      {type: 'field', default: null},\n    startAngle: {type: 'value', default: 0},\n    endAngle:   {type: 'value', default: 2 * Math.PI},\n    sort:       {type: 'value', default: false}\n  });\n\n  this._output = {\n    'start': 'layout_start',\n    'end':   'layout_end',\n    'mid':   'layout_mid'\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Pie.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Pie;\n\nfunction ones() { return 1; }\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['pie']);\n\n  var output = this._output,\n      field = this.param('field').accessor || ones,\n      start = this.param('startAngle'),\n      stop = this.param('endAngle'),\n      sort = this.param('sort');\n\n  var values = data.map(field),\n      a = start,\n      k = (stop - start) / dl.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    Tuple.set(t, output.start, a);\n    Tuple.set(t, output.mid, (a + 0.5 * v * k));\n    Tuple.set(t, output.end, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;",
    "var dl = require('datalib'),\n    log  = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: 'array<field>'} });\n  this.router(true);\n}\n\nvar prototype = (Sort.prototype = Object.create(Transform.prototype));\nprototype.constructor = Sort;\n\nprototype.transform = function(input) {\n  log.debug(input, ['sorting']);\n\n  if (input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.param('by').field);\n  }\n  return input;\n};\n\nmodule.exports = Sort;",
    "var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    sortby: {type: 'array<field>'},\n    field: {type: 'field'},\n    offset: {type: 'value', default: 'zero'}\n  });\n\n  this._output = {\n    'start': 'layout_start',\n    'end':   'layout_end',\n    'mid':   'layout_mid'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Stack.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Stack;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['stacking']);\n\n  var groupby = this.param('groupby').accessor,\n      sortby = dl.comparator(this.param('sortby').field),\n      field = this.param('field').accessor,\n      offset = this.param('offset'),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, field);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset==='center' ? (max - sum)/2 : 0,\n        scale = offset==='normalize' ? (1/sum) : 1,\n        j, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += field(x);\n      b = scale * v + off; // compute end point\n      Tuple.set(x, output.start, a);\n      Tuple.set(x, output.end, b);\n      Tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, field) {\n  var groups = [],\n      get = function(f) { return f(x); },\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = groupby.map(get);\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += field(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;",
    "var df = require('vega-dataflow'),\n    Base = df.Node.prototype, // jshint ignore:line\n    Deps = df.Dependencies,\n    Parameter = require('./Parameter');\n\nfunction Transform(graph) {\n  if (graph) Base.init.call(this, graph);\n}\n\nTransform.addParameters = function(proto, params) {\n  proto._parameters = proto._parameters || {};\n  for (var name in params) {\n    var p = params[name],\n        param = new Parameter(name, p.type, proto);\n\n    proto._parameters[name] = param;\n\n    if (p.type === 'custom') {\n      if (p.set) param.set = p.set.bind(param);\n      if (p.get) param.get = p.get.bind(param);\n    }\n\n    if (p.hasOwnProperty('default')) param.set(p.default);\n  }\n};\n\nvar prototype = (Transform.prototype = Object.create(Base));\nprototype.constructor = Transform;\n\nprototype.param = function(name, value) {\n  var param = this._parameters[name];\n  return (param === undefined) ? this :\n    (arguments.length === 1) ? param.get() : param.set(value);\n};\n\n// Perform transformation. Subclasses should override.\nprototype.transform = function(input/*, reset */) {\n  return input;\n};\n\nprototype.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed.\n  var reset = this._stamp < input.stamp &&\n    this.dependency(Deps.SIGNALS).reduce(function(c, s) {\n      return c += input.signals[s] ? 1 : 0;\n    }, 0);\n  return this.transform(input, reset);\n};\n\nprototype.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;",
    "var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Treeify(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'}\n  });\n\n  this._output = {\n    'children': 'children',\n    'parent':   'parent'\n  };\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Treeify.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Treeify;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['treeifying']);\n\n  var fields = this.param('groupby').field,\n      childField = this._output.children,\n      parentField = this._output.parent,\n      summary = [{name:'*', ops: ['values'], as: [childField]}],\n      aggrs = fields.map(function(f) {\n        return dl.groupby(f).summarize(summary);\n      }),\n      prev = this._internal || [], curr = [], i, n;\n\n  function level(index, node, values) {\n    var vals = aggrs[index].execute(values);\n\n    node[childField] = vals;\n    vals.forEach(function(n) {\n      n[parentField] = node;\n      curr.push(Tuple.ingest(n));\n      if (index+1 < fields.length) level(index+1, n, n[childField]);\n      else n[childField].forEach(function(c) { c[parentField] = n; });\n    });\n  }\n\n  var root = Tuple.ingest({});\n  root[parentField] = null;\n  curr.push(root);\n  level(0, root, data);\n\n  // update changeset with internal nodes\n  for (i=0, n=curr.length; i<n; ++i) {\n    input.add.push(curr[i]);\n  }\n  for (i=0, n=prev.length; i<n; ++i) {\n    input.rem.push(prev[i]);\n  }\n  this._internal = curr;\n\n  return input;\n};\n\nmodule.exports = Treeify;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nvar defaultRatio = 0.5 * (1 + Math.sqrt(5));\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: 'array<field>', default: ['-value']},\n    children: {type: 'field', default: 'children'},\n    parent: {type: 'field', default: 'parent'},\n    field: {type: 'field', default: 'value'},\n    // treemap parameters\n    size: {type: 'array<value>', default: require('./screen').size},\n    round: {type: 'value', default: true},\n    sticky: {type: 'value', default: false},\n    ratio: {type: 'value', default: defaultRatio},\n    padding: {type: 'value', default: null},\n    mode: {type: 'value', default: 'squarify'}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    'x':      'layout_x',\n    'y':      'layout_y',\n    'width':  'layout_width',\n    'height': 'layout_height',\n    'depth':  'layout_depth',\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Treemap.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Treemap;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['treemap']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      sticky = this.param('sticky'),\n      parent = this.param('parent').accessor,\n      root = data.filter(function(d) { return parent(d) === null; })[0];\n\n  // layout.sticky resets state _regardless_ of input value\n  // so, we perform out own check first\n  if (layout.sticky() !== sticky) { layout.sticky(sticky); }\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.param('sort').field))\n    .children(this.param('children').accessor)\n    .value(this.param('field').accessor)\n    .size(this.param('size'))\n    .round(this.param('round'))\n    .ratio(this.param('ratio'))\n    .padding(this.param('padding'))\n    .mode(this.param('mode'))\n    .nodes(root);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    Tuple.set(n, output.x, n.x);\n    Tuple.set(n, output.y, n.y);\n    Tuple.set(n, output.width, n.dx);\n    Tuple.set(n, output.height, n.dy);\n    Tuple.set(n, output.depth, n.depth);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  input.fields[output.depth] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;",
    "var d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    Tuple = require('vega-dataflow/src/Tuple'),\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Voronoi(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    clipExtent: {type: 'array<value>', default: require('./screen').extent},\n    x: {type: 'field', default: 'layout_x'},\n    y: {type: 'field', default: 'layout_y'}\n  });\n\n  this._layout = d3.geom.voronoi();\n  this._output = {'path': 'layout_path'};\n\n  return this.mutates(true);\n}\n\nvar prototype = (Voronoi.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Voronoi;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['voronoi']);\n\n  // get variables\n  var pathname = this._output.path;\n\n  // configure layout\n  var polygons = this._layout\n    .clipExtent(this.param('clipExtent'))\n    .x(this.param('x').accessor)\n    .y(this.param('y').accessor)\n    (data);\n\n  // build and assign path strings\n  for (var i=0; i<data.length; ++i) {\n    Tuple.set(data[i], pathname, 'M' + polygons[i].join('L') + 'Z');\n  }\n\n  // return changeset\n  input.fields[pathname] = 1;\n  return input;\n};\n\nmodule.exports = Voronoi;",
    "var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window['d3'] : typeof global !== \"undefined\" ? global['d3'] : null),\n    d3_cloud = (typeof window !== \"undefined\" ? window['d3']['layout']['cloud'] : typeof global !== \"undefined\" ? global['d3']['layout']['cloud'] : null),\n    canvas = require('vega-scenegraph').canvas,\n    Tuple = require('vega-dataflow/src/Tuple'),\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    Parameter = require('./Parameter');\n\nfunction Wordcloud(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: 'array<value>', default: require('./screen').size},\n    text: {type: 'field', default: 'data'},\n    rotate: {type: 'field|value', default: 0},\n    font: {type: 'field|value', default: {value: 'sans-serif'}},\n    fontSize: {type: 'field|value', default: 14},\n    fontStyle: {type: 'field|value', default: {value: 'normal'}},\n    fontWeight: {type: 'field|value', default: {value: 'normal'}},\n    fontScale: {type: 'array<value>', default: [10, 50]},\n    padding: {type: 'value', default: 1},\n    spiral: {type: 'value', default: 'archimedean'}\n  });\n\n  this._layout = d3_cloud().canvas(canvas.instance);\n\n  this._output = {\n    'x':          'layout_x',\n    'y':          'layout_y',\n    'font':       'layout_font',\n    'fontSize':   'layout_fontSize',\n    'fontStyle':  'layout_fontStyle',\n    'fontWeight': 'layout_fontWeight',\n    'rotate':     'layout_rotate',\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Wordcloud.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Wordcloud;\n\nfunction get(p) {\n  return (p && p.accessor) || p;\n}\n\nfunction wrap(tuple) {\n  var x = Object.create(tuple);\n  x._tuple = tuple;\n  return x;\n}\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['wordcloud']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      fontSize = this.param('fontSize'),\n      range = fontSize.accessor && this.param('fontScale'),\n      size, scale;\n  fontSize = fontSize.accessor || d3.functor(fontSize);\n\n  // create font size scaling function as needed\n  if (range.length) {\n    scale = d3.scale.sqrt()\n      .domain(dl.extent(data, size=fontSize))\n      .range(range);\n    fontSize = function(x) { return scale(size(x)); };\n  }\n\n  // configure layout\n  layout\n    .size(this.param('size'))\n    .text(get(this.param('text')))\n    .padding(this.param('padding'))\n    .spiral(this.param('spiral'))\n    .rotate(get(this.param('rotate')))\n    .font(get(this.param('font')))\n    .fontStyle(get(this.param('fontStyle')))\n    .fontWeight(get(this.param('fontWeight')))\n    .fontSize(fontSize)\n    .words(data.map(wrap)) // wrap to avoid tuple writes\n    .on('end', function(words) {\n      var size = layout.size(),\n          dx = size[0] >> 1,\n          dy = size[1] >> 1,\n          w, t, i, len;\n\n      for (i=0, len=words.length; i<len; ++i) {\n        w = words[i];\n        t = w._tuple;\n        Tuple.set(t, output.x, w.x + dx);\n        Tuple.set(t, output.y, w.y + dy);\n        Tuple.set(t, output.font, w.font);\n        Tuple.set(t, output.fontSize, w.size);\n        Tuple.set(t, output.fontStyle, w.style);\n        Tuple.set(t, output.fontWeight, w.weight);\n        Tuple.set(t, output.rotate, w.rotate);\n      }\n    })\n    .start();\n\n  // return changeset\n  for (var key in output) input.fields[output[key]] = 1;\n  return input;\n};\n\nmodule.exports = Wordcloud;",
    "module.exports = {\n  aggregate:    require('./Aggregate'),\n  bin:          require('./Bin'),\n  cross:        require('./Cross'),\n  countpattern: require('./CountPattern'),\n  linkpath:     require('./LinkPath'),\n  facet:        require('./Facet'),\n  filter:       require('./Filter'),\n  fold:         require('./Fold'),\n  force:        require('./Force'),\n  formula:      require('./Formula'),\n  geo:          require('./Geo'),\n  geopath:      require('./GeoPath'),\n  hierarchy:    require('./Hierarchy'),\n  impute:       require('./Impute'),\n  lookup:       require('./Lookup'),\n  pie:          require('./Pie'),\n  sort:         require('./Sort'),\n  stack:        require('./Stack'),\n  treeify:      require('./Treeify'),\n  treemap:      require('./Treemap'),\n  voronoi:      require('./Voronoi'),\n  wordcloud:    require('./Wordcloud')\n};",
    "module.exports = {\n  size:   [{signal: 'width'}, {signal: 'height'}],\n  mid:    [{expr: 'width/2'}, {expr: 'height/2'}],\n  extent: [\n    {expr: '[-padding.left, -padding.top]'},\n    {expr: '[width+padding.right, height+padding.bottom]'}\n  ]\n};"
  ]
}